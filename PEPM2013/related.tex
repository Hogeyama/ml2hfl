\vspace{-5pt}
\section{Related Work}
\label{sec:related}

%Terauchi2010
There are several
methods~\cite{Ong2011,Kobayashi2010,Unno2010,Rondon2008,Unno2009,Kawaguchi2009,Jhala2011,Xi1999,Xu2009,Xu2012,Chin2003,Suter2010,Suter2011}
that are aimed at verification of functional programs with data
structures.

Ong and Ramsay~\cite{Ong2011} proposed a verification method for 
functional programs with recursive data structures, called Pattern 
Matching Recursion Schemes (PMRS).  The method cannot handle regular 
properties (such as ``a and b occur alternately'') and numerical 
properties (such as ``$x+y \leq z$'' where $x,y,z$ are the length of 
lists).
%regular properties. For example, the method cannot
%verify that a list obtained by applying the following ``id'' function to
%an even length list is also even length.
%\begin{alltt}
%let rec id x = match x with nil -> nil | cons x xs -> cons x (id xs)
%\end{alltt}

Unno et al.~\cite{Unno2010} also proposed a verification method for 
higher-order tree processing functional programs, which is based on a 
verification method for higher-order multi-tree 
transducers~\cite{Kobayashi2010}.  Their method can verify regular 
properties of recursive data structures provided that certain invariant 
annotations are given.
%\cc{This is the heavy burden to programmers}

Rondon et al.'s liquid type inference~\cite{Rondon2008,Kawaguchi2009} is 
a semi-automated verification method based on refinement types.  Their 
method requires users to provide templates of predicates, called logical 
qualifiers.  The expressive power of their method and ours is 
incomparable.  They can deal with ``recursive dependent types'', such as 
$\App{\INT}{\LIST_\leq} = \mu t.\, \NIL$ $\mathop{+} 
\Cons{x_1\COL\INT}{x_2\COL\App{\{\nu\COL\INT \mid x_1 \leq \nu\}}{t}}$, 
which represents ordered lists of integers, while our method cannot. On 
the other hand, our method can deal with the properties of list elements 
related to their indices like ``the $i$-th element of a list is greater 
than $i$,'' while they cannot.
%The limitation of our method is that it cannot
%deal with recursive dependency on recursive data structures such as
%orderedness.  Their method can deal with recursive dependent type
%such that $\App{\INT}{\LIST_\leq} = \mu t.\NIL +
%\Cons{x_1\COL\INT}{x_2\COL\App{\{\nu\COL\INT \mid \nu \leq x_1\}}{t}}$,
%i.e., ordered lists of integers.  The method, however, cannot deal
%with the properties of list elements related to its indices like that
%the $i$-th element of a list is greater than $i$.

%%%Jhala et al.~\cite{Jhala2011} have proposed a verification method that
%%%reduces a safety problem of a higher-order functional program to a safety
%%%problem of a first-order imperative program.
%%%They first prepare refinement type templates, and generates constraints.
%%%Then the constraints are translated to an imperative program.
%%%The program is verified by an existing verifier for imperative programs.
%%%Their method treats data structures such as lists and arrays.
%%%While type templates for data structures must be given in advance,
%%%they cannot deal with user-defined data structures.

Unno and Kobayashi~\cite{Unno2009} proposed a dependent type inference 
method for a higher-order functional language with recursive data 
structures.  Their method prepares templates for dependent types and 
generates constraints.  The constraints are solved by using an 
interpolating theorem prover.

Jhala et al.~\cite{Jhala2011} also proposed a dependent type inference 
method via reduction to verification of first-order imperative programs.
%%%They first prepare refinement type templates, and generates constraints.
%%%Then the constraints are translated to an imperative program.
%%%The program is verified by an existing verifier for imperative programs.
Their method can deal with data structures such as lists and arrays as 
long as type templates for the data structures are given a priori.  
Compared with our ``data structures as functions'' approach, however, 
the supported properties seem to be limited; for example, their method 
cannot reason about a relation between a list index and the 
corresponding element (like ``the \(i\)-th element is greater than 
\(i\)'').

Unlike our method, the refinement type inference methods stated 
above~\cite{Rondon2008,Kawaguchi2009,Unno2009,Jhala2011} do not support 
refinement intersection types, which are necessary for precise, 
context-sensitive analysis of higher-order functions.

Xi and Pfenning~\cite{Xi1999} proposed a dependently-typed language 
Dependent ML.  Its type system captures program properties such as 
absence of array bounds errors and violations of data structure 
invariants.  Unlike our method, Dependent ML requires users to provide 
dependent types of top-level functions.

Xu~\cite{Xu2009,Xu2012} proposed static/hybrid contract checking methods 
for lazy/strict functional languages.  For the static checking to 
succeed, contracts must be declared for top-level functions.

Chin et al.~\cite{Chin2003} proposed sized type inference.  Their method 
infers invariant of recursive functions by fixed-point computation. By 
abstracting lists as multisets, their method can deal with the inclusion 
relation and the membership relation on lists.  For example, their 
method can verify that \texttt{exists x xs} returns true if and only if 
\texttt{xs} has \texttt{x} as an element.  The method, however, cannot 
properly handle higher-order functions.

Suter et al.~\cite{Suter2011} proposed a verification method for 
first-order functional programs that manipulate recursive data 
structures.  They use a decision procedure~\cite{Suter2010} that is 
complete for recursive functions that are sufficiently surjective 
catamorphisms.  For example, their method can verify that an insertion 
function preserves invariants of binary search trees, while our method 
cannot.  On the other hand, their method cannot deal with higher-order 
functions in a context-sensitive way unlike our method.
%general recursion is supported by their SAS paper? McCarthy 91 function

Dillig et al.~\cite{Dillig2011} proposed an automatic technique for
statically reasoning about containers.  The proposed method is based on
an abstract interpretation for containers.  Their method is similar to
our method in the sense that they model containers as mappings from
locations to values.  They consider only a client-side use of specific
data structures (i.e. containers) such as primitive data structures and
those defined in a standard library.  In contrast, our method can deal
with user-defined data structures.  Moreover, as discussed in
Section~\ref{sec:extension}, our method is strictly more expressive than
their method.
%cannot handle higher-order functions?

Beyer et al.~\cite{Beyer2007} proposed a predicate discovery method for 
imperative programs.  Like our method, theirs addresses the problem of 
finding general predicates in the context of a path-sensitive analysis.  
The method uses full-fledged programs (called path programs) as 
counterexamples instead of infeasible error paths (or straightline 
programs).  A path program can be viewed as a set of finite paths that 
are obtained by unwinding the path program.  By synthesizing invariants 
of a path program, their method prevents appearance of infinite simple 
variations of infeasible error paths.  Our method, in a sense, 
generalizes theirs to path- and context-sensitive verification of 
higher-order programs.


%Selective predicate abstraction has some similarity to local type
%inference~\cite{Pierce2000} for reducing type declarations, in the sense
%that the types of non-recursive functions are inferred from the types of
%recursive functions.
