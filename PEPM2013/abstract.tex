\begin{abstract}
In our recent paper, we have shown how to construct a fully-automated
program verification tool (so called a ``software model checker'') for a
tiny subset of functional language ML, by combining higher-order model
checking, predicate abstraction, and CEGAR.  This can be viewed as a
higher-order counterpart of previous software model checkers for
imperative languages like BLAST and SLAM.  The na\"{\i}ve application of
the proposed approach, however, suffered from scalability problems, both
in terms of efficiency and supported language features.  To obtain more
scalable software model checkers for full-scale functional languages, we
propose a series of optimizations and extensions of the previous
approach. Among others, we introduce (i) selective CPS transformation,
(ii) selective predicate abstraction, and (iii) refined predicate
discovery as optimization techniques; and prpose (iv) functional encoding of
recursive data structures and control operations to support a larger
subset of ML.  We have implemented the proposed methods, and obtained
promising results.
%%%Higher-order model checking has been studied recently, and applied to
%%%verification of higher-order functional programs.  In previous work, we
%%%have developed an automated verifier for functional programs. The
%%%verification framework, however, have the following problems: (i) it is
%%%not scalable in a na\"{\i}ve way, and (ii) it cannot directly deal with
%%%recursive data types (e.g., lists and trees) and control operators
%%%(e.g., exceptions and call/ccs), which are necessary to practical
%%%functional languages.
%%%
%%%In this paper, to overcome these problems, we extend and refine the
%%%verification framework in the following way. First, we formalize
%%%functional encoding of recursive data types and control operators.
%%%Second, we define techniques of selective CPS transformation and reduced
%%%abstraction.  We have implemented a prototype verifier for functional
%%%programs based on the framework and tested for several programs.
\end{abstract}



%\section{Introduction}
%[background]
%
%[Show running example of verifying a program with lists]
%
%[discovering general predicates]
%
%[Show running example of expanding non-recursive functions]
%
%[the overview of this framework]
%
%\section{Language}
% [Introduction of the target language (= list constructor/destructor + language of PLDI2011 + pairs.)]
%
%\section{Model Checking for Higher-order Programs with Integers}
% [Introduction of language (of PLDI2011 + pairs.)]
%
% [Description of the framework of PLDI2011.]
%
%\section{Optimization}
%\subsection{Inlining Non-recursive Function}
% [Show an example of the verification with inlining]
%
%\subsection{Selective CPS Transformation}
% [Show an example of the selective CPS transformation]
%
%\section{Functional Encoding of Lists}
% [Show how to encode lists, and how to translate the program with lists]
%\subsection{Extensions for Recursive Data Structures}
% [Show how to encode other data structures]
%
%\section{Extension for Control Operators}
% [Introduce language with control operators (exceptions, call/cc, etc.), and just to say ``Just to do CPS transformation'']
%
%\section{Implementation and Preliminary Experiments}
%
%\section{Related work}
% [Comparison with container abstraction (Dillig et al. POPL11, etc.)]
%
% [Comparison with verification of functional programs with data structures (liquid types, sized types, HMTT, PMRS, etc.)]
%
% [Comparison with others (Soonho Kong et al. APLAS10, etc.)]
%
%\section{Conclusion}
%
%
