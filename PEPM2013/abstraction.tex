
\vspace{-2pt}
\subsection{Selective Predicate Abstraction}

We introduce an optimization technique for predicate abstraction, called
selective predicate abstraction.
%Selective predicate abstraction improves the precision of abstraction.

The idea of selective predicate abstraction is to apply predicate
abstractions only to a certain set of functions and inline the other
functions.  For example, the program in Figure~\ref{fig:sum} can
be verified by abstracting only \texttt{sum} and \texttt{main} as stated
in Section~\ref{sec:intro}.

We formalize selective predicate abstraction as an extension of the
previous predicate abstraction.  In the previous framework, predicate
abstraction is defined as the relation
$\AbstPLDI{\Gamma}{t}{\sigma}{t'}$ which means that $t$ is abstracted to
$t'$ by using the abstraction type $\sigma$ under the assumption that
each free variable $x$ of $t$ has been abstracted using the abstraction
type $\Gamma(x)$.  Abstraction types are types to express which
predicate should be used to abstract each value.  For example, an
abstraction type $\INT[P_1,\dots,P_n]$ means that a value
$v$ of that type should be abstracted to a tuple $(b_1,\dots,b_n)$,
where $b_i$ denotes whether $P_i(v)$ holds or not.  See our previous
paper~\cite{KobayashiPLDI2011} for details.  We extend the predicate
abstraction relation by adding the set of inlined functions $E$ like
$\Abst{\Gamma}{E}{t}{\sigma}{t'}$.  Here, functions in $E$ are not
abstracted and are inlined in the process of abstraction.

%\begin{alltt}
%let pred x = x - 1
%let f x = assert (pred x > 0)
%let main x = if x > 1 then f x else ()
%\end{alltt}
%let rec succ n = n + 1
%    and check1 f = assert (f 1 = 2); check1 f
%    and check2 f = assert (f 2 = 3); check2 f
%    and main b = if b then check1 succ else check2 succ
%In our previous framework, we need the following abstraction types to verify the program.
%\[
% \mathtt{pred}\COL\TFun{a}{}, \mathtt{f}\COL\TFun{}{}, \mathtt{main}\COL\TFun{}{}
%\]
%This program can be verified by using the following abstraction types,
%which denotes how predicates we should use to abstract each terms:
%\begin{eqnarray*}
%\mathtt{succ} &:& \TFun{\INT[\Abs{x}{x=1}, \Abs{x}{x=2}]}{\INT[\Abs{x}{x=2}, \Abs{x}{x=3}]} \\
%\mathtt{check1} &:& \TFun{(\TFun{\INT[\Abs{x}{x=1}]}{\INT[\Abs{x}{x=2}]})}{\UNIT} \\
%\mathtt{check2} &:& \TFun{(\TFun{\INT[\Abs{x}{x=2}]}{\INT[\Abs{x}{x=3}]})}{\UNIT} \enspace .
%\end{eqnarray*}
%The type of \texttt{succ} means that the return value is abstracted by predicates
%$\Abs{x}{x=2}$ and $\Abs{x}{x=3}$ assuming that the argument is
%abstracted by predicates $\Abs{x}{x=1}$ and $\Abs{x}{x=2}$.  In fact, it
%is sufficient for verification to use abstraction type
%$\TFun{\INT[\Abs{x}{x=1}]}{\INT[\Abs{x}{x=2}]}$ for \texttt{succ} in
%\texttt{check1 succ}, and
%$\TFun{\INT[\Abs{x}{x=2}]}{\INT[\Abs{x}{x=3}]}$ for \texttt{succ} in
%\texttt{check2 succ}.  Moreover, we can infer these types of
%\texttt{succ} from the callee sides (i.e., just using the argument type
%of check1 and check2.)

%We formalize this abstraction, called selective predicate abstraction,
%as an extension of the previous predicate abstraction.
Figure~\ref{fig:abstraction} shows the key rules of the selective
predicate abstraction.  Other rules are the same as the previous
predicate abstraction relation~\cite{KobayashiPLDI2011} except that the
set of inlined functions $E$ is added.  The relation
$\Abst{\Gamma}{E}{t}{\tau}{t'}$ means that $t$ is abstracted to $t'$ by
using the abstraction type $\tau$ under the assumption that each free
variable $x \in \Dom{\Gamma}$ of $t$ has been abstracted using the
abstraction type $\Gamma(x)$ and each free variable $x \in \Dom{E}$ of
$t$ is inlined.
%$E=\set{f_{i_1}=v_{i_1},\dots,f_{i_k}=v_{i_k}}$ is a subset of a
%program.
%A function definition is in E intuitively means the function
%is expanded in the abstraction.
If $E$ is empty, the selective predicate abstraction relation is the same as the
previous predicate abstraction.

%\begin{equation*}
%V_{D_1,D_2} = \{f \mid (f,t) \in (D_1 \cup D_2)\}
%\end{equation*}
%\begin{equation*}
%E_{D_1,D_2} = \{(f,g) \mid (f,t) \in D_2, g \in \FV{t}\}
%\end{equation*}
%$\ExpNRec{D_2}{-}$ terminates if the graph $(V_{D_1,D_2},E_{D_1,D_2})$ is acyclic.

%\begin{eqnarray*}
% \ExpNRec{D}{c} &=& c \\
% \ExpNRec{D}{x} &=& \left\{
%                     \begin{array}{ll}
%                      x              & \quad \text{$(x,t) \notin D$ for any $t$}  \\
%                      \ExpNRec{D}{t} & \quad \text{$(x,t) \in D$}
%                     \end{array}
%                    \right. \\
% \ExpNRec{D}{\App{t_1}{t_2}} &=& \App{\ExpNRec{D}{t_1}}{\ExpNRec{D}{t_2}} \\
% \ExpNRec{D}{\Op{v_1,\dots,v_n}} &=& \Op{\ExpNRec{D}{v_1}, \dots, \ExpNRec{D}{v_n}} \\
%% \ExpNRec{D}{\If{t_1}{t_2}{t_3}} &=& \If{\ExpNRec{D}{t_1}}{\ExpNRec{D}{t_2}}{\ExpNRec{D}{t_3}}
%\end{eqnarray*}

%\begin{figure}[t]
%\begin{minipage}{\textwidth}
%\infax[Exp-Int]
% {\Exp{D}{n}{n}}
%
%\medskip
%
%\infrule[Exp-Var1]
% {x = t \notin D \text{ for any } t}
% {\Exp{D}{x}{x}}
%
%\medskip
%
%\infrule[Exp-Var2]
% {\Exp{D}{t}{t'}}
% {\Exp{D,x=t}{x}{t'}}
%
%\medskip
%
%\infrule[Exp-Op]
% {\Exp{D}{v_i}{v_i'} \text{ for each } i}
% {\Exp{D}{\Op{v_1,\dots,v_n}}{\Op{v_1,\dots,v_n}}}
%
%\medskip
%
%\infrule[Exp-Abs]
% {\Exp{D}{t}{t'}}
% {\Exp{D}{\Abs{x}{t}}{\Abs{x}{t'}}}
%
%\medskip
%
%\infrule[Exp-App]
% {\Exp{D}{t_1}{t_1'} \andalso
%  \Exp{D}{t_2 }{t_2'}}
% {\Exp{D}{\App{t_1}{t_2}}{\App{t_1'}{t_2'}}}
%
%\medskip
%
%\infax[Exp-Fail]
% {\Exp{D}{\FAIL}{\FAIL}}
%
%\medskip
%
%\infrule[Exp-If]
% {\Exp{D}{t_1}{t_1'} \andalso
%  \Exp{D}{t_2}{t_2'} \andalso
%  \Exp{D}{t_3}{t_3'}}
% {\Exp{D}{\If{t_1}{t_2}{t_3}}{\If{t_1'}{t_2'}{t_3'}}}
%\end{minipage}
%\caption{Inline Expansion}
%\label{fig:inlining}
%\end{figure}

\begin{figure}[t]
\begin{minipage}{0.47\textwidth}
\small
\infrule[A-App]
 {x\notin\Dom{E} \andalso \Gamma(x)=(y_1\COL\sigma_1 \to \cdots \to y_n\COL\sigma_n \to\sigma) \\
 \begin{array}{ll}
  \Gamma,y_1:\sigma_1,\dots,y_{i-1}:\sigma_{i-1}\mid E \vdash \\
  \quad v_i \COL [v_1/y_1,\ldots,v_{i-1}/y_{i-1}]\sigma_i \leadsto e_i
 \end{array} \text{for each $i\in\set{1,\ldots,n}$}}
 {\Abst{\Gamma}{E}{\App{x}{\seq{v}}}{[\seq{v}/\seq{y}]\sigma}{
  \Let{y_1}{e_1}{\cdots\Let{y_n}{e_n}{\App{x}{\seq{y}}}}}}

\smallskip

\infrule[A-AppExp]
 {E(x) = \Abs{\seq{x}}{e} \andalso
  \Abst{\Gamma}{E}{[\seq{v}/\seq{x}]e}{\sigma}{e'}}
 {\Abst{\Gamma}{E}{\App{x}{\seq{v}}}{\sigma}{e'}}

%\smallskip
%
%\infrule[A-Let]
%  {\Abst{\Gamma}{E,x=e_1}{e_2}{\sigma}{e_2'}}
%  {\Abst{\Gamma}{E}{\Let{x}{e_1}{e_2}}{\sigma}{e_2'}}

\smallskip

\infrule[A-Prog]
  {\Abst{\Gamma}{E}{v_i}{\Gamma(f_i)}{v_i'} \andalso
   \text{for each $i$ s.t. $f_i \notin \Dom{E}$} \\
   E \subseteq {\set{f_1 = v_1, \dots, f_n = v_n}} \andalso
   \Dom{\Gamma} \cap \Dom{E} = \emptyset}
  {\AbstProg{\Gamma}{E}{\set{f_1 = v_1, \dots, f_n = v_n}}{\set{f_i = v_i' \mid f_i \notin \Dom{E}}}}
\end{minipage}
\caption{Selective Predicate Abstraction}
\label{fig:abstraction}
\end{figure}

Figure~\ref{fig:abst-example} shows a part of the abstraction of the
program shown in Figure~\ref{fig:sum} with $E =
(\mathtt{add}=\Abs{x}{\Abs{y}{x+y}})$.  Due to the restriction of the
source language of previous predicate
abstraction~\cite{KobayashiPLDI2011}, we translated the term
$\App{\App{\mathtt{add}}{x}}{\App{\mathtt{sum}}{(x-1)}}$ to
$\Let{s}{\App{\mathtt{sum}}{(x-1)}}{\App{\App{\mathtt{add}}{x}}{s}}$.
In the abstraction of $\App{\App{\mathtt{add}}{x}}{s}$, \texttt{add} is
inlined since the definition of \texttt{add} is in $E$.

\begin{figure}[t]
\small
\infer{
\begin{array}{rr}
 \Gamma \mid
 E \vdash
 \Let{s}{\App{\mathtt{sum}}{(x-1)}}{\App{\App{\mathtt{add}}{x}}{s}} \COL
 \INT[\Abs{r}{r \geq x}] \leadsto \quad \\
 \Let{s}{\App{\mathtt{sum}}{()}}{t}
\end{array}
}{
\vdots \qquad
 &
\infer{
 \Abst
  {\Gamma'}
  {E}
  {\App{\App{\mathtt{add}}{x}}{s}}
  {\INT[\Abs{r}{r \geq x}]}
  {t}
}{
\infer{
 \Abst
  {\Gamma'}
  {E}
  {x + s}
  {\INT[\Abs{r}{r \geq x}]}
  {t}
}{\vdots}}}

\caption{Abstraction of $\App{\App{\mathtt{add}}{x}}{(\App{\mathtt{sum}}{(x-1)})}$.
 ($*$ is a syntactic sugar for $\Br{\TRUE}{\FALSE}$.
  $\Gamma = x\COL\INT[], \mathtt{sum}\COL(\TFun{y\COL\INT[]}{\INT[\Abs{r}{r \geq y}]}),~ x>0$.
  $\Gamma' = \Gamma,~s\COL\INT[\Abs{s}{s \geq x-1}]$.
  $E = (\mathtt{add}=\Abs{x}{\Abs{y}{x+y}})$.
  $t = \If{s}{\TRUE}{*}$.)}
\label{fig:abst-example}
\end{figure}
%\begin{figure}[t]
%\infer{
% \Abst
%  {\Gamma}
%  {E}
%  {\Let{s}{\App{\mathtt{sum}}{(x-1)}}{\App{\App{\mathtt{add}}{x}}{s}}}
%  {\INT[\Abs{r}{r \geq x}]}{\Let{s}{\App{\mathtt{sum}}{()}}{t}}
%}{
%\infer{
% \Abst
%  {\Gamma}
%  {E}
%  {\App{\mathtt{sum}}{(x-1)}}
%  {\INT[\Abs{r}{r \geq x-1}]}
%  {\App{\mathtt{sum}}{()}}}
% {\vdots}
% &
%\infer{
% \Abst
%  {\Gamma'}
%  {E}
%  {\App{\App{\mathtt{add}}{x}}{s}}
%  {\INT[\Abs{r}{r \geq x}]}
%  {t}
%}{
%\infer{
% \Abst
%  {\Gamma'}
%  {E}
%  {x + s}
%  {\INT[\Abs{r}{r \geq x}]}
%  {t}
%}{\vdots}}}
%
%\caption{Abstraction of $\App{\App{\mathtt{add}}{x}}{(\App{\mathtt{sum}}{(x-1)})}$.
% ($*$ is a syntactic sugar for $\Br{\TRUE}{\FALSE}$.
%  $\Gamma = x\COL\INT[], \mathtt{sum}\COL(\TFun{y\COL\INT[]}{\INT[\Abs{r}{r \geq y}]}),~ x>0$.
%  $\Gamma' = \Gamma,~s\COL\INT[\Abs{s}{s \geq x-1}]$.
%  $E = (\mathtt{add}=\Abs{x}{\Abs{y}{x+y}})$.
%  $t = \If{s}{\TRUE}{*}$.)}
%\label{fig:abst-example}
%\end{figure}

For some $D$ and $E$, there is $D'$ such that
$\AbstProg{\Gamma}{E}{D}{D'}$ as long as there is no cyclic definitions
in $E$ like $\set{f = \Abs{x}{\App{g}{x}},~ g = \Abs{y}{f}}$.
Therefore, one way to decide $E$ is to find a maximal set of the
functions that has no cyclic definitions.
%Therefore, recursive functions
%should be basically in $\Dom{\Gamma}$, and non-recursive functions
%should be in $\Dom{E}$.
Even if $E$ has some functions which are recursive in $D$,
there is $D'$ such that $\AbstProg{\Gamma}{E}{D}{D'}$ in some cases.
For example, the following program can be abstracted with $E = \set{\mathtt{odd} = v_\mathtt{odd}}$.
\vspace{-5pt}
\begin{alltt}
 letrec even x = if x = 0 then true else odd (x-1)
     and odd x = if x = 0 then false else even (x-1)
 let main () = assert (even (n+n))
\end{alltt}
\vspace{-5pt}
The following is the abstraction of the program with $\Gamma =
\mathtt{even}\COL\TFun{\INT[P_e]}{\BOOL},
\mathtt{main}\COL\TFun{\INT[]}{\UNIT}$ where $P_e = \Abs{x}{(x
\mathop{\mathrm{mod}} 2 = 0})$.
\vspace{-15pt}
\begin{alltt}
 letrec even b =
   if (if b then * else false) then true
   else if (if b then false else *) then false
   else even b
 let main () = assert (even b)
\end{alltt}
\vspace{-5pt}
The abstracted program is safe.  For comparison, consider
the case where $\Gamma = \mathtt{even}\COL\TFun{\INT[P_e]}{\BOOL},
\mathtt{odd}\COL\TFun{\INT[]}{\BOOL},
\mathtt{main}\COL\TFun{\INT[]}{\UNIT}$ and $E=\emptyset$ (which
corresponds to our previous approach~\cite{KobayashiPLDI2011} where the predicates for
\texttt{odd} have not been found yet).
\vspace{-5pt}
\begin{alltt}
 letrec even b = if (if b then * else false)
                 then true else odd ()
    and odd () = if * then false else even *
 let main () = assert (even b)
\end{alltt}
\vspace{-5pt}
Since the abstraction of \texttt{odd} is too coarse, the abstracted
\texttt{even} returns a non-deterministic booleans.  Thus, the
abstracted program is unsafe.

We discuss properties of the selective predicate abstraction.
The theorem below states that selective predicate abstraction is sound
in the sense that if the original program fails then so does its
abstracted program.
\begin{theorem}[Soundness of Selective Predicate Abstraction]
\label{thm:abst_sound}
 If $\AbstProg{\Gamma}{E}{D_1}{D_2}$, and
 $\App{\main}{n} \Reds{D_1} \FAIL$, then
 $\App{\main}{n} \Reds{D_2} \FAIL$.
\end{theorem}

%\begin{theorem}
% If $\Abst{\Gamma}{D}{t}{\tau}{t_1}$,
% $\Abst{\Gamma}{D'}{t}{\tau}{t_2}$,
% $D \subseteq D'$,
% $t_1 \reds \FAIL$ then
% $t_2 \reds \FAIL$.
%\end{theorem}

The following property can be proved in the same manner as the soundness
of the previous predicate abstraction~\cite{KobayashiPLDI2011}.
\begin{prop}
 If $\AbstPLDI{\Gamma}{D}{\tau}{D_1}$,
 $\AbstProg{\Gamma}{E}{D}{D_2}$, and
 $\App{\main}{n} \Reds{D_2} \FAIL$, then
 $\App{\main}{n} \Reds{D_1} \FAIL$.
\end{prop}
The proposition above states that selective predicate abstraction is
more precise compared to our previous predicate abstraction.  Here,
$\AbstPLDI{\Gamma}{D}{\tau}{D_1}$ is the predicate abstraction relation in
our previous paper~\cite{KobayashiPLDI2011}.

%As a consequence of the theorem, we can show that selective predicate
%abstraction with higher-order model checking has at least the same
%verification power of the

%\begin{figure}[t]
%\begin{minipage}{\textwidth}
%
%\infrule[Aff-Const]
% {}
% {\AffineT{S}{f}{n}}
%
%\medskip
%
%\infrule[Aff-Var1]
% {f \in S}
% {\AffineT{S}{f}{f}}
%
%\medskip
%
%\infrule[Aff-Var2]
% {f \neq x}
% {\AffineT{S}{f}{x}}
%
%\medskip
%
%\infax[Aff-Op]
% {\AffineT{S}{f}{\Op{v_1,\dots,v_n}}}
%
%\medskip
%
%\infrule[Aff-Abs]
% {\AffineT{S}{f}{t}}
% {\AffineT{S}{f}{\Abs{x}{t}}}
%
%\medskip
%
%\infrule[Aff-App]
% {\AffineT{S_1}{f}{t_1} \andalso
%  \AffineT{S_2}{f}{t_2} \andalso
%  S = S_1 \uplus S_2}
% {\AffineT{S}{f}{\App{t_1}{t_2}}}
%
%\medskip
%
%\infrule[Aff-Fail]
% {}
% {\AffineT{S}{f}{\FAIL}}
%
%\medskip
%
%\infrule[Aff-If]
% {\AffineT{S_1}{f}{t_1} \andalso
%  \AffineT{S_2}{f}{t_2} \andalso
%  \AffineT{S_2}{f}{t_3} \andalso
%  S = S_1 \uplus S_2}
% {\AffineT{S}{f}{\If{t_1}{t_2}{t_3}}}
%
%\medskip
%
%\infrule[Aff-Prog]
% {\AffineT{S_i}{f}{t_i} \texttt{ for each $i$} \andalso
%  \{f\} = \biguplus S_i}
% {\Affine{f}{\{f_1=t_1,\dots,f_n=t_n\}}}
%
%\end{minipage}
%\caption{Definitions of $\Affine{-}{-}$ \memo{Can we define $\Affine{-}{-}$ only in writing?}}
%\label{fig:affine}
%\end{figure}



%\begin{theorem}
% Suppose Let $t$ be a term in program $D \supseteq D'$, there exists $t'$ such that $...$, if
% $\Affine{f_i}{D}$ holds or $t_i$ is closed, for each definition $f_i = t_i$ in $D'$:
%\end{theorem}
%Here, the definition of $\Affine{-}{-}$ is in
%Fig.~\ref{fig:affine}. $\Affine{f_i}{D}$ denotes $f_i$ is occurred at
%most once except that it counts as ones if $f_i$ occurred at most once
%each in the then-part and the else-part of an if-expression.
