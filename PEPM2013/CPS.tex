\vspace{-5pt}
\section{Optimizations}
\label{sec:opt}

This section introduces optimizations for each phase of CPS
transformation (Step 2) and predicate abstraction (Step 1) in
Figure~\ref{fig:cegar}.


\subsection{Selective CPS transformation}
\label{sec:CPS}
%\TODO{Add discussion about the increase of the order of programs}

This section formalizes selective CPS transformation for abstracted
programs.  As stated in Section~\ref{sec:intro}, the idea of the selective
CPS transformation is to distinguish whether a continuation parameter
should be inserted to each expression or not based on whether it has a
side-effect.  When a function application has no side-effects, we need
not insert a continuation.  Here, $\FAIL$,
non-deterministic branch, and non-termination are considered as
side-effects.
%For example, since an
%application of function $\Abs{x}{\Abs{y}{\Assert{x+y}}}$ to a value has
%no side-effects, it can be transformed to CPS by inserting only one
%continuation like $\Abs{x}{\Abs{y}{\Abs{k}{\App{k}{(x+y)}}}}$ instead of
%$\Abs{x}{\Abs{k}{\App{k}{(\Abs{y}{\Abs{k'}{\App{k'}{(x+y)}}})}}}$.

Note that a similar transformation has been proposed by
Nielsen~\cite{Nielsen2001}.  The transformation does not fit our purpose
to translate call-by-value programs into equivalent call-by-name
programs.  A non-terminating program may be transformed into a
terminating (call-by-name) program by their transformation.
%The reason is that programs obtained by their transformation do not
%yield the same results under a call-by-value semantics and a
%call-by-name semantics.  To be more precise, the transformation does not
%treat non-termination as a side-effect.

To decide whether we should insert a continuation or not, we
annotate each function type with a label $\ell \in \{\NC,\IC\}$, like
$\TFunL{\ell}{\tau_1}{\tau_2}$.  A type $\TFunC{\tau_1}{\tau_2}$ means
that we should insert a continuation, and $\TFunN{\tau_1}{\tau_2}$ means
not.

%\begin{example}[Selective CPS Transformation]
%Consider the following program.
%\begin{alltt}
%let apply = \(\lambda\)x.\(\lambda\)f. f x
%let check = \(\lambda\)x.\(\lambda\)y. assert (x = y)
%let main = \(\lambda\)n. apply n (check n)
%\end{alltt}
%We can translated this program into the following program by na\"{\i}ve CPS transformation.
%\begin{alltt}
%let apply = \(\lambda\)x.\(\lambda\)k1. k1 (\(\lambda\)f.\(\lambda\)k2. f x k2)
%let check = \(\lambda\)x.\(\lambda\)k1. k1 (\(\lambda\)y.\(\lambda\)k2. assert (x = y); k2 ())
%let main = \(\lambda\)n.\(\lambda\)k. check n (\(\lambda\)f1. apply n (\(\lambda\)f2. f2 f1 k))
%\end{alltt}
%The order of this program is \emph{fifth}, i.e. the order of \texttt{apply}.
%%\mathtt{apply}\COL\TFun{\INT}{\TFun{(\TFun{(\TFun{(\TFun{\INT}{\TFun{(\TFun{\INT}{\UNIT})}{\UNIT}})}{\TFun{(\TFun{\INT}{\UNIT})}{\UNIT}})}{\UNIT})}{\UNIT}}
%On the other hand, considering the following annotated program,
%\begin{alltt}
%let apply = \(\lambda\sp{\NC}\)x.\(\lambda\sp{\IC}\)f. f x
%let check = \(\lambda\sp{\IC}\)x.\(\lambda\sp{\IC}\)y. assert (x = y)
%let main = \(\lambda\sp{\IC}\)n. apply n (check n)
%\end{alltt}
%we can translate the program into the following \emph{third} order CPS program.
%\begin{alltt}
%let apply = \(\lambda\)x.\(\lambda\)f.\(\lambda\)k. f x k
%let check = \(\lambda\)x.\(\lambda\)k1. = k1 (\(\lambda\)y.\(\lambda\)k. assert (x = y); k ())
%let main = \(\lambda\)n.\(\lambda\)k. check n (\(\lambda\)f. apply n f k)
%\end{alltt}
%\end{example}

%We used the model checker TRecS in our previous verifier.  Described in
%Section~\ref{model-check}, since TRecS is a model checker for
%higher-order recursion scheme, we need CPS transformation to apply TRecS
%to call-by-value programs.  A na\"{\i}ve CPS transformation, however,
%becomes programs complicate and higher-order.
%
%A selective CPS transformation is a CPS transformation that only
%transforms functions with side effects.

We first define the source language of selective CPS transformation.
The language is the same as the one in Section~\ref{sec:language} except: (i) the set
of terms is extended with non-deterministic branch $\Br{t_1}{t_2}$, and (ii)
a label $\ell \in \{\NC,\IC\}$ is attached to each function type, like
$\TFunL{\ell}{\tau_1}{\tau_2}$.

%\begin{eqnarray*}
% t\text{ (terms)} &::=& \cdots \mid \AbsT{x}{\tau}{t} \mid \AbsTC{x}{\tau}{t} \\
% v\text{ (values)} &::=& \cdots \mid \AbsT{x}{\tau}{t} \mid \AbsTC{x}{\tau}{t} \\
% \tau\text{ (types)} &::=& \cdots \mid \TFunC{\tau_1}{\tau_2}
%\end{eqnarray*}

Below, we formalize the selective CPS as a type-based transformation.
Figure~\ref{fig:cps} shows the rules of the selective CPS
transformation.  The relation $\CPS{\Gamma}{t}{\tau}{\ell}{t'}$ means
that a term $t$ is translated to a term $t'$ by using a type $\tau$,
under the assumption that (i) each free variable $x$ of $t$ has been
transformed using the type $\Gamma(x)$, (ii) $t$ may have a side-effect if
$\ell=\IC$, and (iii) $t$ has no side-effect if $\ell=\NC$.
%Here, $\MAbs{x}{t}$ and
%$\MApp{t_1}{t_2}$ are, respectively, application and abstraction that
%will be reduced statically in the translation.

\begin{figure}[tp]
\begin{minipage}{0.47\textwidth}

\infax[CPS-Const]
 {\CPS{\Gamma}{n}{\INT}{\NC}{n}}

\smallskip

\infax[CPS-Var]
 {\CPS{\Gamma,x\COL\tau}{x}{\tau}{\NC}{x}}

\smallskip

\infrule[CPS-Op]
 {\CPS{\Gamma}{v_i}{\INT}{\NC}{v_i'} \quad \text{for each $i \in \set{1,\dots,n}$}}
 {\CPS{\Gamma}{\Op{v_1,\dots,v_n}}{\INT}{\NC}{\Op{v_1',\dots,v_n'}}}

\smallskip

\infrule[CPS-AbsN]
 {\CPS{\Gamma, x\COL\tau_1}{t}{\tau_2}{\NC}{t'}}
 {\CPS{\Gamma}{\Abs{x}{t}}{\TFunN{\tau_1}{\tau_2}}{\NC}{\Abs{x}{t'}}}

\smallskip

\infrule[CPS-AbsC]
 {\CPS{\Gamma, x\COL\tau_1}{t}{\tau_2}{\ell}{t'}}
 {\CPS{\Gamma}{\Abs{x}{t}}{\TFunL{C}{\tau_1}{\tau_2}}{\NC}
  {\Abs{x}{\Abs{k}{\SApp{\ell}{t'}{k}}}}}

\smallskip

\infrule[CPS-AppN]
 {\CPS{\Gamma}{t_0}{\TFunN{\tau_1}{\tau}}{\NC}{t_0'} \quad
  \CPS{\Gamma}{t_1}{\tau_1}{\NC}{t_1'}}
 {\CPS{\Gamma}{\App{t_0}{t_1}}{\tau}{\NC}
  {\App{t_0'}{t_1'}}}

\smallskip

\infrule[CPS-AppC]
 {\CPS{\Gamma}{t_0}{\TFunL{\ell}{\tau_1}{\tau}}{\ell_0}{t_0'} \andalso
  \CPS{\Gamma}{t_1}{\tau_1}{\ell_1}{t_1'}}
 {
 \begin{array}{l}
  \Gamma \p \App{t_0}{t_1} \COL \tau, \IC \leadsto \\
  \qquad \Abs{k}{\SApp{\ell_0}{t_0'}{\Abs{x_0}{\SApp{\ell_1}{t_1'}{\Abs{x_1}{\SApp{\ell}{\App{x_0}{x_1}}{k}}}}}}
 \end{array}}

%\smallskip
%
%\infrule[CPS-AppN]
% {\CPS{\Gamma}{t_0}{\TFunN{\tau_1}{\TFunN{\cdots}{\TFunN{\tau_n}{\tau}}}}{\NC}{t_0'} \andalso
%  \CPS{\Gamma}{t_i}{\tau_i}{\NC}{t_i'} \quad \text{for each $i \in \set{1,\dots,n}$}}
% {\CPS{\Gamma}{\App{\App{\App{t_0}{t_1}}{\dots}}{t_n}}{\tau}{\NC}
%  {\App{\App{\App{t_0'}{t_1'}}{\ldots}}{t_n'}}}
%
%\smallskip
%
%\infrule[CPS-AppC]
% {\CPS{\Gamma}{t_0}{\TFunL{l_1}{\tau_1}{\TFunL{l_{n-1}}{\cdots}{\TFunL{l_n}{\tau_n}{\tau}}}}{l_0}{t_0'} \andalso
%  \CPS{\Gamma}{t_i}{\tau_i}{l_i}{t_i'} \quad \text{for each $i \in \set{1,\dots,n}$}}
% {\CPS{\Gamma}{\App{\App{\App{t_0}{t_1}}{\dots}}{t_n}}{\tau}{\IC}
%  {\Abs{k}{\SApp{l_0}{t_0'}{\Abs{x_0}{\SApp{l_1}{t_1'}{\Abs{x_1}{\cdots\SApp{l_n}{t_n'}{\Abs{x_n}{\App{\App{\App{\App{x_0}{x_1}}{\ldots}}{x_n}}{k}}}\cdots}}}}}}}
%
\smallskip

\infax[CPS-Fail]
 {\CPS{\Gamma}{\FAIL}{\tau}{\IC}{\Abs{k}{\FAIL}}}

\smallskip

\infrule[CPS-IfN]
 {\CPS{\Gamma}{t_1}{\INT}{\NC}{t_1'} \quad
  \CPS{\Gamma}{t_2}{\tau}{\NC}{t_2'} \quad
  \CPS{\Gamma}{t_3}{\tau}{\NC}{t_3'}}
 {\CPS{\Gamma}{\If{t_1}{t_2}{t_3}}{\tau}{\NC}
  {\If{t_1'}{t_2'}{t_3'}}}

\smallskip

\infrule[CPS-IfC]
 {\CPS{\Gamma}{t_1}{\INT}{\ell_1}{t_1'} \quad
  \CPS{\Gamma}{t_2}{\tau}{\ell_2}{t_2'} \quad
  \CPS{\Gamma}{t_3}{\tau}{\ell_3}{t_3'}}
 {\begin{array}{l}
   \CPS{\Gamma}{\If{t_1}{t_2}{t_3}}{\tau}{\IC}{}{\lambda k.\,\mathit{App}^{\ell_1}(t_1,} \\
   \qquad \Abs{m}{\If{m}{\SApp{\ell_2}{t_2'}{k}}{\SApp{\ell_3}{t_3'}{k}}})
  \end{array}}

\smallskip

 \infrule[CPS-Br]
 {\CPS{\Gamma}{t_1}{\tau}{\ell_1}{t_1'} \andalso
  \CPS{\Gamma}{t_2}{\tau}{\ell_2}{t_2'}}
 {
 \begin{array}{l}
  \Gamma \p \Br{t_1}{t_2} \COL \tau, \IC \leadsto \\
  \qquad \Abs{k}{\If{\Br{0}{1}}{\SApp{\ell_1}{t_2'}{k}}{\SApp{\ell_2}{t_3'}{k}}}
 \end{array}}

\smallskip

\infrule[CPS-Prog]
 {v_i \text{ is of the form } \Abs{x_1}{\Abs{x_2}{\dots\Abs{x_j}{t_i}}} \\
  t_i \text{ is not of the form } \Abs{x}{t_i'} \\
  \Gamma(f_i) \text{ is of the form } \TFunL{\ell_1}{\tau_{i1}}{\TFunL{\ell_2}{\tau_{i2}}{\TFunL{\ell_{j-1}}{\cdots}{\TFunC{\tau_{ij}}{\tau}}}} \\
  \CPS{\Gamma}{v_i}{\Gamma(f_i)}{\NC}{v_i'} \quad \text{for each $i \in \set{1,\dots,n}$}}
 {\CPSprog{\Gamma}{\{f_1=v_1,\dots,f_n=v_n\}}{\{f_1=v_1',\dots,f_n=v_n'\}}}

\begin{center}
$\SApp{\NC}{t}{k} = \App{k}{t}$, \quad $\SApp{\IC}{t}{k} = \App{t}{k}$
\end{center}

\end{minipage}
\caption{Selective CPS transformation}
\label{fig:cps}
\end{figure}

%\begin{figure}[htbp]
%\begin{minipage}{\textwidth}
%\infax[CPS-Const]
% {\CPS{\Gamma}{n}{\INT}{\NC}{\Abs{\kappa}{\App{\kappa}{n}}}}
%
%\smallskip
%
%\infax[CPS-Var]
% {\CPS{\Gamma,x\COL\tau}{x}{\tau}{\NC}{\Abs{\kappa}{\App{\kappa}{x}}}}
%
%\smallskip
%
%\infax[CPS-Op]
% {\CPS{\Gamma}{\Op{v_1,\dots,v_n}}{\INT}{\NC}{\Abs{\kappa}{\App{\kappa}{(\Op{v_1,\dots,v_n})}}}}
%
%\smallskip
%
%\infrule[CPS-AbsN]
% {\CPS{\Gamma, x\COL\tau_1}{t}{\tau_2}{\NC}{t'}}
% {\CPS{\Gamma}{\Abs{x}{t}}{\TFunN{\tau_1}{\tau_2}}{\NC}
%  {\Abs{\kappa}{\Abs{x}{\App{t'}{(\Abs{m}{\App{\kappa}{m}})}}}}}
%
%\smallskip
%
%\infrule[CPS-AbsC]
% {\CPS{\Gamma, x\COL\tau_1}{t}{\tau_2}{\IC}{t'}}
% {\CPS{\Gamma}{\Abs{x}{t}}{\TFunC{\tau_1}{\tau_2}}{\NC}
%  {\Abs{\kappa}{\App{\kappa}{(\Abs{x}{\Abs{k}{\App{t'}{(\Abs{m}{\App{k}{m}})}}})}}}}
%
%\smallskip
%
%\infrule[CPS-AppN]
% {\text{$t_0$ is not of the form $\App{\App{\App{f}{t_{00}}}{\ldots}}{t_{0k}}$} \\
%  \CPS{\Gamma}{t_0}{\TFunN{\tau_1}{\TFunN{\cdots}{\TFunN{\tau_n}{\tau}}}}{\NC}{t_0'} \andalso
%  \CPS{\Gamma}{t_i}{\tau_i}{\NC}{t_i'} \quad \text{for each $i \in \set{1,\dots,n}$}}
% {\CPS{\Gamma}{\App{\App{\App{t_0}{t_1}}{\dots}}{t_n}}{\tau}{\NC}
%  {\Abs{\kappa}{\App{\kappa}{(\App{t_0'}{(\Abs{x_0}{\App{t_1'}{(\Abs{x_1}{\cdots(\Abs{x_n}{\App{\App{\App{x_0}{x_1}}{\ldots}}{x_n}})\cdots})}})})}}}}
%
%\smallskip
%
%\infrule[CPS-AppC]
% {\CPS{\Gamma}{t_0}{\TFunL{l_1}{\tau_1}{\TFunL{l_{n-1}}{\cdots}{\TFunC{\tau_n}{\tau}}}}{l}{t_0'} \andalso
%  \CPS{\Gamma}{t_i}{\tau_i}{l_i'}{t_i'} \quad \text{for each $i \in \set{1,\dots,n}$}}
% {\CPS{\Gamma}{\App{\App{\App{t_0}{t_1}}{\dots}}{t_n}}{\tau}{\IC}
%  {\Abs{\kappa}{\App{t_0'}{(\Abs{x_0}{\App{t_1'}{(\Abs{x_1}{\cdots(\Abs{x_n}{\App{\App{\App{\App{x_0}{x_1}}{\ldots}}{x_n}}{(\Abs{r}{\App{\kappa}{r}})}})\cdots})}})}}}}
%
%\smallskip
%
%\infax[CPS-Fail]
% {\CPS{\Gamma}{\FAIL}{\tau}{\IC}{\Abs{\kappa}{\FAIL}}}
%
%\smallskip
%
%\infrule[CPS-If]
% {\CPS{\Gamma}{t_1}{\INT}{l}{t_1'} \andalso
%  \CPS{\Gamma}{t_2}{\tau}{l}{t_2'} \andalso
%  \CPS{\Gamma}{t_3}{\tau}{l}{t_3'}}
% {\CPS{\Gamma}{\If{t_1}{t_2}{t_3}}{\tau}{l}
%  {\Abs{\kappa}{\App{t_1}{(\Abs{m}{\If{m}{\App{t_2'}{\kappa}}{\App{t_3'}{\kappa}}})}}}}
%
%\smallskip
%
%\infrule[CPS-Br]
% {\CPS{\Gamma}{t_1}{\tau}{l_1}{t_1'} \andalso
%  \CPS{\Gamma}{t_2}{\tau}{l_2}{t_2'}}
% {\CPS{\Gamma}{\Br{t_1}{t_2}}{\tau}{\IC}
%  {\Abs{\kappa}{\If{\Br{0}{1}}{\App{t_2'}{\kappa}}{\App{t_3'}{\kappa}}}}}
%
%\smallskip
%
%\infrule[CPS-Prog]
% {\CPS{\Gamma}{v_i}{\Gamma(f_i)}{\NC}{v_i'} \quad \text{for each $i \in \set{1,\dots,n}$}}
% {\CPSprog{\Gamma}{\{f_1=v_1,\dots,f_n=v_n\}}{\{f_1=\App{v_1}{(\Abs{m}{m})},\dots,f_n=\App{v_n}{(\Abs{m}{m})}\}}}
%
%%\begin{eqnarray*}
%% \CPSty{b} &=& b \\
%% \CPSty{\TFunC{\tau_1}{\tau_2}} &=& \TFun{\CPSty{\tau_1}}{\TFun{(\TFun{\CPSty{\tau_2}}{\UNIT})}{\UNIT}} \\
%% \CPSty{\TFun{\tau_1}{\tau_2}} &=& \TFun{\CPSty{\tau_1}}{\CPSty{\tau_2}}
%%\end{eqnarray*}
%\end{minipage}
%\caption{Selective CPS transformatation}
%\label{fig:cps}
%\end{figure}

The rules are designed in such a way that transformed term $t'$ has type
$\CPSty{\tau}$ if $\CPS{\Gamma}{t}{\tau}{N}{t'}$ holds, and the transformed
term $t'$ has type $\TFun{(\TFun{\CPSty{\tau}}{\AT})}{\AT}$ if
$\CPS{\Gamma}{t}{\tau}{C}{t'}$ holds, where $\AT$ is the answer type and
$\CPSty{\tau}$ is defined by:
\vspace{-5pt}
\[
\begin{array}{rcl}
 \CPSty{\INT} &=& \INT \\
 \CPSty{\TFunN{\tau_1}{\tau_2}} &=& \TFun{\CPSty{\tau_1}}{\CPSty{\tau_2}} \\
 \CPSty{\TFunC{\tau_1}{\tau_2}} &=& \TFun{\CPSty{\tau_1}}{\TFun{(\TFun{\CPSty{\tau_2}}{\AT})}{\AT}}
\end{array}
\]

This shows the intuition that a term of a type $\TFunC{\tau_1}{\tau_2}$
should be inserted a continuation, and another term remains in direct
style.

In the rule \rn{CPS-AbsC}, a term $\Abs{x}{t}$ is transformed in a
standard way, i.e. a continuation parameter $k$ is inserted and $t'$,
the CPS version of $t$, is applied to $k$.  On the other hand, in the
rule \rn{CPS-AbsN}, no continuation parameter is inserted and direct
style is preserved.  The rules for applications are similar. In the rule
\rn{CPS-AppC}, a continuation is inserted, but not in the rule
\rn{CPS-AppN}.  In the rule \rn{CPS-Br}, a term $\Br{t_1}{t_2}$ should
be transformed with $\IC$ and a continuation is needed because we need to treat
non-deterministic branch as a side-effect.  In the rule \rn{CPS-Prog},
since an application of a top-level function may cause a side-effect,
non-termination, the function type for the last argument is annotated
with $\IC$.  For the sake of simplicity, regardless of whether functions
are recursive, we consider all the top-level functions may not terminate
conservatively.
%Although this is a na\"{\i}ve way to transform non-terminating terms.
We can avoid redundant insertion of continuations
by some termination analysis.

{
\def\check{\mathtt{check}}
\def\apply{\mathtt{apply}}
\def\assert{\mathtt{assert}}
\def\assertcps{\mathtt{assert}_\mathtt{CPS}}

Figure~\ref{fig:cps-example} shows examples of the selective CPS
transformation.  The examples are the transformations of
$\Abs{x}{\Abs{y}{\assert(x = y)}}$ with type
$\TFunN{\INT}{\TFunC{\INT}{\INT}}$ for (a) and
$\TFunC{\INT}{\TFunC{\INT}{\INT}}$ for (b).
The transformation of $\Abs{y}{\assert(x = y)}$ in (b) is the same as the one in (a).
In (a), there is no need to insert a continuation parameter to the back of $x$.
On the other hand, in (b), a continuation parameter is inserted.

\begin{figure}[tp]
\begin{minipage}{\textwidth}
\begin{minipage}{0.03\textwidth}
(a)
\end{minipage}
\begin{minipage}{0.9\textwidth}
\infer{
\CPS{\Gamma}
     {\Abs{x}{\Abs{y}{t}}}
     {\TFunN{\INT}{\TFunC{\INT}{\INT}}}{\NC}
     {\Abs{x}{\Abs{y}{\Abs{k}{\App{t'}{k}}}}}
}{
\infer{
 \CPS{\Gamma_x}
     {\Abs{y}{t}}
     {\TFunC{\INT}{\INT}}{\NC}
     {\Abs{y}{\Abs{k}{\App{t'}{k}}}}
}{
\infer{
 \CPS{\Gamma_{xy}}
     {t}
     {\INT}{\IC}
     {\Abs{k}{\App{t'}{k}}}
}{
 \CPS{\Gamma_{xy}}{\assert}{\TFunC{\INT}{\INT}}{\NC}{\assertcps}
  &
 \quad \vdots \quad
}}}
\end{minipage}

\begin{minipage}{\textwidth}
\begin{minipage}{0.05\textwidth}
(b)
\end{minipage}
\begin{minipage}{0.9\textwidth}
\infer{
 \begin{array}{r}
 \Gamma \p
 \Abs{x}{\Abs{y}{t}} \COL
 \TFunC{\INT}{\TFunC{\INT}{\INT}}, \NC \leadsto \qquad \\
 \Abs{x}{\Abs{k'}{\App{k'}{(\Abs{y}{\Abs{k}{\App{t'}{k}}})}}}
 \end{array}
}{
\infer{
 \CPS{\Gamma_x}
     {\Abs{y}{t}}
     {\TFunC{\INT}{\INT}}{\NC}
     {\Abs{y}{\Abs{k}{\App{t'}{k}}}}
}{\vdots}}
\end{minipage}
\end{minipage}
\end{minipage}
\caption{Transformations of $\Abs{x}{\Abs{y}{\assert(x =
y)}}$. ($t = \assert(x =y)$, $t' = \assertcps(x =y)$, $\Gamma_x=\Gamma,x\COL\INT$.
$\Gamma_{xy}=\Gamma_x,y\COL\INT$. $\App{\App{\assertcps}{b}}{k}$ asserts
$b$ and returns $\App{k}{()}$)} \label{fig:cps-example}
\end{figure}
}

In the following, we discuss properties of the selective CPS
transformation.  The theorem below states that we can transform
arbitrary simply-typed programs by the selective CPS transformation.
\begin{theorem}
\label{thm:cps_total}
Suppose $D$ is typable in $\Gamma$. There exists $\Gamma'$ and $D'$ such
that $\Gamma = \ElimAnnot{\Gamma'}$ and $\CPSprog{\Gamma'}{D}{D'}$,
where $\ElimAnnot{\Gamma}$ is a function that maps an environment with
annotations into the corresponding environment without annotations.
\end{theorem}
The following theorem states the soundness of the selective CPS
transformation, that the transformed program is reduced to
the same value as the original program.
\begin{theorem}[Soundness of CPS Transformation]
\label{thm:cps_sound}
If $\CPSprog{\Gamma}{D}{D'}$, then the following holds:
$\App{\main}{n} \Reds{D} \FAIL$ if and only if
$\App{\App{\main}{n}}{(\Abs{x}{x})} \Reds{D'} \FAIL$.
\end{theorem}

%\memo{How to infer types and labels?}
