\vspace{-2mm}

\section{Implementation and Preliminary Experiments}
\label{sec:experiments}

\vspace{-1mm}

To evaluate the extended framework, we have implemented a prototype
verifier for higher-order programs with lists and exceptions.
%The verifier takes an OCaml program as input.
Our verifier uses TRecS~\cite{KobayashiPOPL2009,KobayashiPPDP2009} as
the underlying higher-order model checker (for Step 3 in
Fig.~\ref{fig:cegar}), and uses CSIsat~\cite{Beyer2008} for predicate
discovery (for Step 5).  CVC3~\cite{Barrett2007} is used for unsafety
check (for Step 4) and predicate abstraction (for Step 1).

Table~\ref{tbl:exp} shows the results of the experiments.  The column
``size'' shows the word counts of the program.  The last column shows
the number of CEGAR-cycles and the running time measured.  In the last
column, ``C.'' and ``A.'' denote the uses of selective CPS
transformation and selective predicate abstraction, respectively.  The
programs have been verified correctly.  The experiment was conducted on
Intel Xeon 5570 CPU with 8 MB cache and 6 GB memory.  The implementation
can be tested and all programs are available at
\url{http://www.kb.ecei.tohoku.ac.jp/~ryosuke/mochi/}.

\begin{table}
\caption{Results of preliminary experiments}
\label{tbl:exp}
\begin{center}
\begin{tabular}{|l|r|r|r|r|r|r|r|}
\hline
            &       &    & \multicolumn{4}{|c|}{cycle, time [sec]} \\
\cline{4-7}
program    & size & order & none &     C. &   A. &    C. and A. \\
\hline
%intro1     &    27&      2& 1,  0.07 & 1,  0.06 & 0,  0.06 & 0,  0.06 \\
%intro2     &    29&      2& 1,  0.06 & 1,  0.10 & 0,  0.06 & 0,  0.06 \\
%intro3     &    30&      2& 1,  0.08 & 1,  0.07 & 0,  0.07 & 0,  0.06 \\
 sum        &    24&      1& 2, 0.14 & 2, 0.13 & 1, 0.09 & 1, 0.08 \\
\bf  mult       &\bf     31&\bf       1&\bf  5, 48.94 &\bf  4, 42.49 &\bf  3, 0.18 &\bf  2, 0.14 \\
\bf  max        &\bf     42&\bf       2&\bf  5, 2.17 &\bf  5, 0.85 &\bf  1, 0.20 &\bf  0, 0.08 \\
 mc91       &    32&      1& 2, 0.20 & 2, 0.19 & 2, 0.18 & 2, 0.16 \\
\bf  ack        &\bf     53&\bf       1&\bf  - &\bf  - &\bf  1, 0.14 &\bf  1, 0.10 \\
%repeat     &    37&      2&        - &        - &        - &        - \\
%fhnhn      &    37&      2&  ,       &  ,       &  ,       &  ,       \\
%hrec       &    34&      2& 2,  0.14 & 2,  0.15 & 1,  0.10 & 1,  0.09 \\
%neg        &    47&      2& 1,  0.20 & 1,  0.13 & 0,  0.07 & 0,  0.06 \\
%a-prod     &    70&      2& 8,  2.80 &        - & 4,       &  ,       \\
\bf  a-cppr     & \bf   149&\bf       2&\bf  13, 359.88 &\bf  12, 10.14 &\bf  6, 1.13 &\bf  6, 1.18 \\
%a-init     &    96&      2&  ,       &  ,       &  ,       &  ,       \\
\bf  a-max      &\bf     70&\bf       2&\bf  - &\bf  6, 20.02 &\bf  3, 2.04 &\bf  3, 1.29 \\
\bf l-zipunzip &\bf     81&\bf       2&\bf  - &\bf  6, 1.24 &\bf  - &\bf  2, 0.14 \\
 l-zipmap   &    65&      2& 6, 0.76 & 5, 1.04 & 2, 0.13 & 2, 0.13 \\
 hors       &    64&      2& 2, 0.28 & 2, 0.15 & 1, 0.10 & 1, 0.08 \\
 e-simple   &    27&      2& 1, 0.08 & 1, 0.07 & 0, 0.06 & 0, 0.06 \\
 e-fact     &    55&      2& 2, 0.12 & 2, 0.10 & 2, 0.09 & 2, 0.10 \\
 r-lock     &    54&      1& 6, 0.49 & 6, 0.30 & 0, 0.07 & 0, 0.07 \\
\bf  r-file     &\bf    168&\bf       1&\bf  - &\bf  13, 5.55 &\bf  - &\bf  7, 0.79 \\
 sum-e      &    26&      1& 0, 0.06 & 0, 0.08 & 0, 0.06 & 0, 0.07 \\
 mult-e     &    33&      1& 1, 0.10 & 1, 0.11 & 0, 0.07 & 1, 0.10 \\
 mc91-e     &    32&      1& 0, 0.08 & 0, 0.08 & 0, 0.07 & 0, 0.08 \\
 repeat-e   &    35&      2& 0, 0.08 & 0, 0.08 & 0, 0.07 & 0, 0.07 \\
 a-max-e    &    70&      2& 3, 0.60 & 3, 0.33 & 2, 0.36 & 2, 0.29 \\
 r-lock-e   &    54&      1& 2, 0.15 & 2, 0.12 & 0, 0.09 & 0, 0.08 \\
%excep-e    &    27&      2&  ,       &  ,       &  ,       &  ,       \\
%\end{tabular}
%\begin{tabular}{|l|r|r|r|r|r|r|r|}
%\hline
%            &       &    & \multicolumn{4}{|c|}{cycle, time [sec]} \\
%\cline{4-7}
%program    & size & order & no opt. &     CPS &   abst. &    both \\
\hline
 sum\_intro        &  33 & 1 & 2, 0.15 & 2, 0.14 & 1, 0.08 & 1, 0.08 \\
\bf  fold\_right       &\bf   64 &\bf  2 &\bf  5, 4.18 &\bf  6, 3.72 &\bf  2, 0.26 &\bf  2, 0.16 \\
\bf forall\_eq\_pair  &  55 & 1 & 6, 389.42 & - & 1, 0.14 & 1, 0.15 \\
\bf  forall\_leq       &\bf   55 &\bf  2 &\bf  4, 1.77 &\bf  4, 0.95 &\bf  1, 0.15 &\bf  1, 0.13 \\
 isnil             &  52 & 1 & 3, 0.23 & 3, 0.19 & 2, 0.15 & 2, 0.16 \\
\bf  iter              &\bf   59 &\bf  2 &\bf  4, 1.50 &\bf  4, 0.84 &\bf  1, 0.12 &\bf  1, 0.11 \\
%length3           &  50 & 1 &       - &       - &       - & -, -    \\
 mem               &  74 & 1 & 4, 1.17 & 4, 0.58 & 3, 0.34 & 3, 0.27 \\
 nth0              &  78 & 1 & 3, 0.41 & 3, 0.32 & 3, 0.28 & 3, 0.24 \\
\bf  harmonic          &\bf  101 &\bf  2 &\bf  5, 6.73 &\bf  5, 2.70 &\bf  1, 0.22 &\bf  1, 0.17 \\
\bf  fold\_left        &\bf   64 &\bf  2 &\bf  6, 167.54 &\bf  5, 2.30 &\bf  2, 0.31 &\bf  2, 0.17 \\
%iter\_fun\_list   &  59 & 3 &       - &       - &       - & -, -    \\
\bf  zip               &\bf   69 &\bf  1 &\bf  - &\bf  - &\bf  - &\bf  2, 0.24 \\
%map               &  85 & 2 &       - &       - &       - & -, -    \\
\bf  map\_filter &\bf  111 &\bf  2 &\bf  - &\bf  - &\bf  2, 1.16 &\bf  3, 0.81 \\
\bf  risers            &\bf   79 &\bf  1 &\bf  - &\bf  - &\bf  4, 1.80 &\bf  4, 1.32 \\
%ground  &   - & - & - & - & - & - & - & - \\
 fact\_notpos      &  97 & 3 & 5, 0.35 & 5, 0.22 & 3, 0.16 & 3, 0.13 \\
\bf  fun\_list         &\bf    94&\bf  3 &\bf  - &\bf  13, 84.79 &\bf  6, 15.70 &\bf  6, 11.12 \\
\hline
\end{tabular}
\end{center}
\end{table}

%All programs except ... are list manipulating ones.  Almost programs
%define a generator of lists and functions on lists, and assert that the
%functions work correctly.
The programs used in the experiments are:
\begin{itemize}
\item ``r-lock-e'' and above are the programs used in the experiments in
      the previous paper~\cite{KobayashiPLDI2011}.
\item ``sum\_intro'' is the example program in Sect.~\ref{sec:intro}.
\item ``map\_head\_filter'' and ``risers'' are examples of Ong and
      Ramsay's verification framework~\cite{Ong2011} for higher-order
      recursion scheme with a \textit{case} construct listed at their
      web page
      \url{http://mjolnir.cs.ox.ac.uk/cgi-bin/horsc/recheck-horsc/input}.
      Our framework can verify these programs without a special
      treatment of case constructs unlike in their framework.
\item ``fact'' is the example program in Sect.~\ref{sec:control}.
\item Other programs define generators of lists and functions on lists,
      and assert that the functions work correctly.  For example,
      ``zip'' defines a function that takes two lists and returns a list of corresponding pairs.
      The function fails if the two arguments have different lengths.
      ``zip'' asserts that \texttt{zip xs xs} never fails for all integer lists \texttt{xs}.
\end{itemize}
%\begin{itemize}
%%\item ``fold\_right'' defines
%\item ``forall\_eq\_pair'' defines a generator of lists of the form
%      $[(n_1,n_1);\dots;(n_k,n_k)]$, and function \texttt{forall} that
%      takes a predicate $p$ as a function and a list and checks if all
%      elements of the list satisfy the $p$.
%\item ``forall\_leq'' defines a generator of positive integer lists and
%      the function \texttt{forall}.
%\item ``isnil'' defines a generator of integer lists and a function that
%      takes a list and checks whether the list is nil or not.
%\item ``iter'' defines a generator of positive integer lists and the
%      function \texttt{iter}.
%\item ``mem'' defines a generator of lists consists of the same elements
%      and function \texttt{mem} that takes a value and a list, then
%      checks the value is in the list.
%\item ``nth0'' defines a generator of integer lists and function
%      ``nth'' that takes an index $i$ and a list and returns $i$-th element of the list.
%\item ``harmonic'' defines a function that calculates $\sum_{1 \leq k}
%      \frac{n}{k}$ for some $n$, $k$ using a fold function for lists.
%      The program asserts that a zero division cannot occurs.
%\item ``fold\_left'' defines a fold function for lists and sum function
%      using the fold.
%\item ``zip'' defines a function that takes two lists and returns the
%      list of pairs that consists of elements of arguments.
%\item ``map\_head\_filter'' is an example of Ong and Ramsay's verification
%      framework~\cite{Ong2011} for higher-order recursion scheme with a
%      \textit{case} construct listed in their web page
%      \url{http://mjolnir.cs.ox.ac.uk/cgi-bin/horsc/recheck-horsc/input}.
%      This defines map, head, is\_nil, and filter function for lists, and
%      asserts that head does not fail in the calculation of \texttt{map
%      head (filter head xs)} for all list \texttt{xs}.
%\item ``risers'' is also an example of Ong and Ramsay's verification
%      framework~\cite{Ong2011}.  This defines a function that takes a list and splits
%      the list into a list of lists such that each element is an
%      ascending list.
%\end{itemize}

The applications of two optimization techniques enable verification of the
programs such as ``zip'' and ``map\_head\_filter'', and reduce the
running time.  Especially, the application of selective CPS
transformation reduces the running time, and selective predicate
abstraction reduces the number of CEGAR cycles.

%\begin{itemize}
%\item fold\_right
%\begin{alltt}
%let rec fold_right (f:int->int->int) xs acc =
%  match xs with
%    [] -> acc
%  | x::xs' -> f x (fold_right f xs' acc)
%
%let rec make_list n =
%  if n < 0
%  then []
%  else n :: make_list (n-1)
%
%let add x y = x + y
%
%let main n m =
%  let xs = make_list n in
%    assert (fold_right add xs m >= m)
%\end{alltt}
%
%\item forall\_eq\_pair
%\begin{alltt}
%let rec for_all f (xs:(int*int) list) =
%  match xs with
%      [] -> true
%    | x::xs' ->
%        f x && for_all f xs'
%
%let rec eq_pair ((x:int),(y:int)) = x = y
%
%let rec make_list n =
%  if n < 0
%  then []
%  else (n,n) :: make_list (n-1)
%
%let main n = assert (for_all eq_pair (make_list n))
%\end{alltt}
%
%\item forall\_leq
%\begin{alltt}
%let rec for_all f (xs:int list) =
%  match xs with
%      [] -> true
%    | x::xs' ->
%        f x && for_all f xs'
%
%let rec check x = x >= 0
%
%let rec make_list n =
%  if n < 0
%  then []
%  else n :: make_list (n-1)
%
%let main n = assert (for_all check (make_list n))
%\end{alltt}
%
%\item isnil
%\begin{alltt}
%let is_nil (xs:int list) =
%  match xs with
%      [] -> true
%    | _ -> false
%
%let rec make_list n =
%  if n = 0
%  then []
%  else n :: make_list (n-1)
%
%let main n =
%  let xs = make_list n in
%    if n > 0
%    then assert (not (is_nil xs))
%    else ()
%\end{alltt}
%
%\item iter
%\begin{alltt}
%let rec iter (f:int -> unit) xs =
%  match xs with
%      [] -> ()
%    | x::xs' -> f x; iter f xs'
%
%let rec make_list n =
%  if n < 0
%  then []
%  else n :: make_list (n-1)
%
%let check x = assert (x >= 0)
%
%let main n =
%  let xs = make_list n in
%    iter check xs
%\end{alltt}
%
%\item length3
%\begin{alltt}
%let rec length (xs:int list) =
%  match xs with
%      [] -> 0
%    | _::xs' -> 1 + length xs'
%
%let rec make_list n =
%  if n = 0
%  then []
%  else n :: make_list (n-1)
%
%let main n =
%  let xs = make_list n in
%    assert (length xs = n)
%\end{alltt}
%
%\item mem
%\begin{alltt}
%let rec mem (x:int) xs =
%  match xs with
%      [] -> false
%    | x'::xs -> x = x' || mem x xs
%
%let rec make_list n (x:int) =
%  if n < 0
%  then []
%  else x :: make_list (n-1) x
%
%let is_nil (xs:int list) =
%  match xs with
%      [] -> true
%    | _ -> false
%
%let main n m =
%  let xs = make_list n m in
%    assert (is_nil xs || mem m xs)
%\end{alltt}
%
%\item nth0
%\begin{alltt}
%let is_nil (xs:int list) =
%  match xs with
%      [] -> true
%    | _ -> false
%
%let rec nth n (xs:int list) =
%  match xs with
%    | [] -> assert false
%    | x::xs' -> if n = 0 then x else nth (n-1) xs'
%
%let rec make_list n =
%  if n < 0
%  then []
%  else n :: make_list (n-1)
%
%let main n =
%  let xs = make_list n in
%    if is_nil xs
%    then 0
%    else nth 0 xs
%\end{alltt}
%
%\item harmonic
%\begin{alltt}
%let rec div x y =
%  assert (y <> 0);
%  if x < y
%  then 0
%  else 1 + div (x-y) y
%
%let rec fold_left (f:int->int->int) acc xs =
%  match xs with
%      [] -> acc
%    | x::xs' -> fold_left f (f acc x) xs'
%
%let rec range i j =
%  if i > j then
%    []
%  else
%    let is = range (i+1) j in
%      i::is
%
%let harmonic n =
%  let ds = range 1 n in
%    fold_left (fun s k -> s + div 10000 k) 0 ds
%\end{alltt}
%
%\item fold\_left
%\begin{alltt}
%let rec fold_left (f:int->int->int) acc xs =
%  match xs with
%      [] -> acc
%    | x::xs' -> fold_left f (f acc x) xs'
%
%let rec make_list n =
%  if n < 0
%  then []
%  else n :: make_list (n-1)
%
%let add x y = x + y
%
%let main n m =
%  let xs = make_list n in
%    assert (fold_left add m xs >= m)
%\end{alltt}
%
%\item iter\_fun\_list
%\begin{alltt}
%let rec iter (f:(int->unit)->unit) xs =
%  match xs with
%      [] -> ()
%    | x::xs' -> f x; iter f xs'
%
%let rec make_list n =
%  if n < 0
%  then []
%  else (fun x -> assert (n >= x)) :: make_list (n-1)
%
%let main n =
%  let xs = make_list n in
%    iter (fun f -> f 0) xs
%\end{alltt}
%
%
%\item map
%\begin{alltt}
%let rec map f xs =
%  match xs with
%      [] -> []
%    | x::xs' -> f x :: map f xs'
%
%let rec length xs =
%  match xs with
%      [] -> 0
%    | _::xs' -> 1 + length xs'
%
%let rec make_list n =
%  if n < 0
%  then []
%  else n :: make_list (n-1)
%
%let succ x = x + 1
%
%let main n =
%  let xs = make_list n in
%  let xs' = map succ xs in
%    assert (length xs = length xs')
%\end{alltt}
%
%\item zip
%\begin{alltt}
%let rec zip xs ys =
%  match xs with
%      [] ->
%        begin
%          match ys with
%              [] -> []
%            | _ -> assert false
%        end
%    | x::xs' ->
%        match ys with
%            [] -> assert false
%          | y::ys' -> (x,y)::zip xs' ys'
%
%let rec make_list n =
%  if n < 0
%  then []
%  else n :: make_list (n-1)
%
%let main n =
%  let xs = make_list n in
%    zip xs xs
%\end{alltt}
%
%\item inits
%\begin{alltt}
%let rec make_list m =
%  if m <= 0
%  then []
%  else Random.int 0 :: make_list (m-1)
%
%let rec make_list_list m =
%  if m <=0
%  then []
%  else make_list (Random.int 0) :: make_list_list (m-1)
%
%let head = function
%    [] -> assert false
%  | x::xs -> x
%
%let ne = function
%    [] -> 0
%  | x::xs -> 1
%
%let rec filter p = function
%    [] -> []
%  | x::xs -> if p x = 1 then x::(filter p xs) else filter p xs
%
%let rec map f = function
%    [] -> []
%  | x::xs -> f x :: map f xs
%
%let main m = map head (filter ne (make_list_list m))
%\end{alltt}
%
%\end{itemize}
