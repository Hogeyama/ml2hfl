
\vspace{-5pt}
\section{Implementation and Preliminary Experiments}
\label{sec:experiments}

To evaluate the extended framework, we have implemented a prototype
verifier for higher-order programs with lists and exceptions.
%The verifier takes an OCaml program as input.
Our verifier uses TRecS~\cite{KobayashiPOPL2009,KobayashiPPDP2009} as
the underlying higher-order model checker (for Step 3 in
Figure~\ref{fig:cegar}), and uses CSIsat~\cite{Beyer2008} for predicate
discovery (in Step 5).  CVC3~\cite{Barrett2007} is used for unsafety
check (in Step 4) and predicate abstraction (in Step 1).

Table~\ref{tbl:exp} shows the results of the experiments.  The column
``size'' shows the word counts of the program.  The last column shows
the number of CEGAR-cycles and the running time measured.  In the last
column, ``C.'', ``A.'', and ``D.''  denote the uses of selective CPS
transformation, selective predicate abstraction, and refined predicate
discovery, respectively.  The programs have been verified correctly.
The experiment was conducted on Intel Xeon 5570 CPU with 8 MB cache and
6 GB memory.  The implementation can be tested and all programs are
available at \url{http://www.kb.ecei.tohoku.ac.jp/~ryosuke/mochi/}.

\begin{table*}
\caption{Results of preliminary experiments}
\label{tbl:exp}
\small
\begin{center}
\begin{tabular}{|l|r|r|p{0pt}r|p{0pt}r|p{0pt}r|p{0pt}r|p{0pt}r|p{0pt}r|p{0pt}r|}
\hline
            &       &    & \multicolumn{10}{|c|}{cycle, time [sec]} \\
\cline{4-13}
program    & size & order & \multicolumn{2}{c}{none} &     \multicolumn{2}{|c|}{C.} &   \multicolumn{2}{|c|}{A.} & \multicolumn{2}{|c|}{C. \& A.} & \multicolumn{2}{|c|}{C. \& A. \& D.} \\
\hline
sum               &    24&  1&  2, &    0.14 &  2, &    0.14 &  1, &    0.06 &  1, &    0.07 &  1, &    0.08 \\
\bf mult              & \bf    31& \bf  1& \bf     & \bf       - & \bf     & \bf       - & \bf  3, & \bf    0.16 & \bf  3, & \bf    0.14 & \bf  3, & \bf    0.16 \\
max               &    42&  2&  5, &    5.07 &  5, &    1.63 &  1, &    0.17 &  3, &    0.87 &  3, &    0.93 \\
mc91              &    32&  1&  2, &    0.21 &  2, &    0.21 &  2, &    0.16 &  2, &    0.16 &  2, &    0.36 \\
\bf ack               & \bf    53& \bf  1& \bf     & \bf       - & \bf     & \bf       - & \bf  1, & \bf    0.10 & \bf  1, & \bf    0.10 & \bf  1, & \bf    0.10 \\
\bf a-cppr            & \bf   149& \bf  2& \bf     & \bf       - & \bf 12, & \bf   33.91 & \bf  6, & \bf    1.31 & \bf  6, & \bf    1.06 & \bf  6, & \bf    1.06 \\
\bf l-zipunzip        & \bf    81& \bf  2& \bf     & \bf       - & \bf     & \bf       - & \bf     & \bf       - & \bf  2, & \bf    0.14 & \bf  2, & \bf    0.14 \\
\bf l-zipmap          & \bf    65& \bf  2& \bf     & \bf       - & \bf  6, & \bf    0.54 & \bf  2, & \bf    0.11 & \bf  2, & \bf    0.10 & \bf  3, & \bf    0.16 \\
hors              &    64&  2&  2, &    0.36 &  2, &    0.11 &  1, &    0.09 &  1, &    0.07 &  1, &    0.06 \\
e-simple          &    27&  2&  1, &    0.08 &  1, &    0.08 &  0, &    0.06 &  0, &    0.06 &  0, &    0.06 \\
e-fact            &    55&  2&  2, &    0.14 &  2, &    0.11 &  2, &    0.10 &  2, &    0.09 &  2, &    0.09 \\
r-lock            &    54&  1&  6, &    1.00 &  6, &    0.49 &  0, &    0.07 &  0, &    0.06 &  0, &    0.07 \\
\bf r-file            & \bf   168& \bf  1& \bf     & \bf       - & \bf     & \bf       - & \bf  9, & \bf    2.76 & \bf 12, & \bf    2.18 & \bf 10, & \bf   81.50 \\
\hline
sum\_intro        &   33 & 1 &  2, &    0.18 &  2, &    0.15 &  1, &    0.08 &  1, &    0.08 &  1, &    0.08 \\
\bf copy\_intro       & \bf   24 & \bf 1 & \bf     & \bf       - & \bf     & \bf       - & \bf     & \bf       - & \bf     & \bf       - & \bf  2, & \bf    0.14 \\
fact\_notpos      &   97 & 1 &  1, &    0.11 &  1, &    0.11 &  1, &    0.08 &  1, &    0.09 &  1, &    0.08 \\
fold\_right       &   64 & 2 &  8, &  361.07 &  8, &  167.05 &  2, &    0.31 &  2, &    0.18 &  2, &    0.34 \\
\bf forall\_eq\_pair  & \bf   55 & \bf 1 & \bf     & \bf       - & \bf     & \bf       - & \bf     & \bf       - & \bf  1, & \bf    0.22 & \bf  1, & \bf    0.27 \\
\bf forall\_leq       & \bf   55 & \bf 2 & \bf     & \bf       - & \bf  7, & \bf   93.28 & \bf  1, & \bf    0.20 & \bf  1, & \bf    0.16 & \bf  1, & \bf    0.24 \\
isnil             &   52 & 1 &  3, &    0.28 &  3, &    0.24 &  2, &    0.13 &  2, &    0.13 &  2, &    0.12 \\
\bf iter              & \bf   59 & \bf 2 & \bf     & \bf       - & \bf  7, & \bf   15.70 & \bf  1, & \bf    0.16 & \bf  1, & \bf    0.13 & \bf  1, & \bf    0.17 \\
\bf length            & \bf   49 & \bf 1 & \bf     & \bf       - & \bf     & \bf       - & \bf     & \bf       - & \bf     & \bf       - & \bf  2, & \bf    0.14 \\
mem               &   74 & 1 &  6, &    5.45 &  5, &    1.74 &  3, &    0.41 &  2, &    0.34 &  2, &    0.31 \\
\bf nth               & \bf   59 & \bf 1 & \bf     & \bf       - & \bf     & \bf       - & \bf     & \bf       - & \bf     & \bf       - & \bf  4, & \bf    0.58 \\
nth0              &   78 & 1 &  4, &    0.88 &  4, &    0.61 &  2, &    0.23 &  2, &    0.19 &  2, &    0.25 \\
\bf harmonic          & \bf  101 & \bf 2 & \bf     & \bf       - & \bf     & \bf       - & \bf  1, & \bf    0.32 & \bf  1, & \bf    0.18 & \bf  1, & \bf    0.29 \\
\bf fold\_left        & \bf   64 & \bf 2 & \bf     & \bf       - & \bf     & \bf       - & \bf  8, & \bf  157.05 & \bf  2, & \bf    0.35 & \bf  2, & \bf    0.36 \\
\bf zip               & \bf   69 & \bf 1 & \bf     & \bf       - & \bf     & \bf       - & \bf     & \bf       - & \bf  3, & \bf    0.37 & \bf  3, & \bf    0.35 \\
\bf isort\_geq        & \bf   97 & \bf 1 & \bf     & \bf       - & \bf     & \bf       - & \bf     & \bf       - & \bf     & \bf       - & \bf  7, & \bf   97.59 \\
\bf map\_filter       & \bf  111 & \bf 2 & \bf     & \bf       - & \bf     & \bf       - & \bf  2, & \bf    3.23 & \bf  2, & \bf    1.87 & \bf  3, & \bf   27.51 \\
\bf risers            & \bf   79 & \bf 1 & \bf     & \bf       - & \bf     & \bf       - & \bf  4, & \bf    2.51 & \bf  4, & \bf    1.69 & \bf  3, & \bf    2.07 \\
\bf arith\_exp        & \bf  109 & \bf 2 & \bf     & \bf       - & \bf     & \bf       - & \bf  4, & \bf    8.65 & \bf  3, & \bf    1.68 & \bf  4, & \bf    6.32 \\
\bf fun\_list         & \bf   94 & \bf 3 & \bf     & \bf       - & \bf     & \bf       - & \bf  6, & \bf   23.18 & \bf  6, & \bf   12.52 & \bf  8, & \bf   33.15 \\
harmonic-e        &  101 & 2 &  1, &    0.44 &  1, &    0.22 &  0, &    0.11 &  0, &    0.08 &  0, &    0.08 \\
map\_filter-e     &  111 & 2 &  2, &    2.29 &  2, &    1.11 &  0, &    0.16 &  0, &    0.15 &  0, &    0.16 \\
arith\_exp-e      &  109 & 2 &  7, &   22.85 &     &       - &  3, &    3.22 &  2, &    1.04 &  3, &    4.52 \\
fact\_notpos-e    &   97 & 1 &  0, &    0.07 &  0, &    0.08 &  0, &    0.08 &  0, &    0.06 &  0, &    0.08 \\
\hline
\end{tabular}
\end{center}
\end{table*}

%All programs except ... are list manipulating ones.  Almost programs
%define a generator of lists and functions on lists, and assert that the
%functions work correctly.
The programs used in the experiments are:
\vspace{-5pt}
\begin{itemize}
\item ``r-file'' and above are the programs used in the experiments in
      the previous paper~\cite{KobayashiPLDI2011}.
\item ``sum\_intro'', ``copy\_intro'', and ``fact\_notpos'' are the example programs in
      Section~\ref{sec:intro} and Section{sec:control}.
\item ``map\_head\_filter'' and ``risers'' are examples of Ong and
      Ramsay's verification framework~\cite{Ong2011} for higher-order
      recursion scheme with a \textit{case} construct listed at their
      web page
      \url{http://mjolnir.cs.ox.ac.uk/cgi-bin/horsc/recheck-horsc/input}.
      Our framework can verify these programs without a special
      treatment of case constructs unlike in their framework.
\item ``arith\_exp'' is a program that manipulates user-defined data structures.
\item Other programs define generators of lists and functions on lists,
      and assert that the functions work correctly.  For example,
      ``zip'' defines a function that takes two lists and returns a list of corresponding pairs.
      The function fails if the two arguments have different lengths.
      ``zip'' asserts that \texttt{zip xs xs} never fails for all integer lists \texttt{xs}.
\item A program of name ``xxx-e'' is a buggy version of the program ``xxx''.
\end{itemize}
\vspace{-5pt}
%\begin{itemize}
%%\item ``fold\_right'' defines
%\item ``forall\_eq\_pair'' defines a generator of lists of the form
%      $[(n_1,n_1);\dots;(n_k,n_k)]$, and function \texttt{forall} that
%      takes a predicate $p$ as a function and a list and checks if all
%      elements of the list satisfy the $p$.
%\item ``forall\_leq'' defines a generator of positive integer lists and
%      the function \texttt{forall}.
%\item ``isnil'' defines a generator of integer lists and a function that
%      takes a list and checks whether the list is nil or not.
%\item ``iter'' defines a generator of positive integer lists and the
%      function \texttt{iter}.
%\item ``mem'' defines a generator of lists consists of the same elements
%      and function \texttt{mem} that takes a value and a list, then
%      checks the value is in the list.
%\item ``nth0'' defines a generator of integer lists and function
%      ``nth'' that takes an index $i$ and a list and returns $i$-th element of the list.
%\item ``harmonic'' defines a function that calculates $\sum_{1 \leq k}
%      \frac{n}{k}$ for some $n$, $k$ using a fold function for lists.
%      The program asserts that a zero division cannot occurs.
%\item ``fold\_left'' defines a fold function for lists and sum function
%      using the fold.
%\item ``zip'' defines a function that takes two lists and returns the
%      list of pairs that consists of elements of arguments.
%\item ``map\_head\_filter'' is an example of Ong and Ramsay's verification
%      framework~\cite{Ong2011} for higher-order recursion scheme with a
%      \textit{case} construct listed in their web page
%      \url{http://mjolnir.cs.ox.ac.uk/cgi-bin/horsc/recheck-horsc/input}.
%      This defines map, head, is\_nil, and filter function for lists, and
%      asserts that head does not fail in the calculation of \texttt{map
%      head (filter head xs)} for all list \texttt{xs}.
%\item ``risers'' is also an example of Ong and Ramsay's verification
%      framework~\cite{Ong2011}.  This defines a function that takes a list and splits
%      the list into a list of lists such that each element is an
%      ascending list.
%\end{itemize}

The applications of selective CPS transformation and selective predicate
abstraction enable verification of the programs such as ``zip'' and
``map\_head\_filter'', and reduce the running time.  Especially, the
application of selective CPS transformation reduces the running time,
and selective predicate abstraction reduces the number of CEGAR cycles.
The new predicate discovery enables verification of the programs such as
``length'' and ``nth''.

Note that the column of ``C. \& A. \& D.'' is evaluated using a
predicate discovery that uses only a single infeasible error
path instead of multiple infeasible error paths.  While consideration of
multiple paths enhances the precision of predicate abstraction, it slows
down verifications for some programs (such as ``map\_filter'') since the
implementation is preliminary.  However, there are programs which can be
verified by using multiple paths, and not be verified by using a single path.
The following is such a program.
\begin{alltt}
let rec length acc xs = match xs with [] -> acc
                      | _::xs' -> length (acc+1) xs'
let rec make_list n = if n = 0 then []
                      else n :: make_list (n-1)
let main n = assert (length 0 (make_list n) = n)
\end{alltt}
For the verification of this program, we need the predicate
$\LENGTH(\mathtt{acc}) + \LENGTH(\mathtt{xs}) = \LENGTH(\mathtt{r})$ on
the argument $\mathtt{acc}$, $\mathtt{xs}$ and the return value
$\mathtt{r}$ argement of \texttt{length}.  Actually, we verified
the program in 0.36 seconds with 3 CEGAR-cycles by using multiple paths.

%\begin{itemize}
%\item fold\_right
%\begin{alltt}
%let rec fold_right (f:int->int->int) xs acc =
%  match xs with
%    [] -> acc
%  | x::xs' -> f x (fold_right f xs' acc)
%
%let rec make_list n =
%  if n < 0
%  then []
%  else n :: make_list (n-1)
%
%let add x y = x + y
%
%let main n m =
%  let xs = make_list n in
%    assert (fold_right add xs m >= m)
%\end{alltt}
%
%\item forall\_eq\_pair
%\begin{alltt}
%let rec for_all f (xs:(int*int) list) =
%  match xs with
%      [] -> true
%    | x::xs' ->
%        f x && for_all f xs'
%
%let rec eq_pair ((x:int),(y:int)) = x = y
%
%let rec make_list n =
%  if n < 0
%  then []
%  else (n,n) :: make_list (n-1)
%
%let main n = assert (for_all eq_pair (make_list n))
%\end{alltt}
%
%\item forall\_leq
%\begin{alltt}
%let rec for_all f (xs:int list) =
%  match xs with
%      [] -> true
%    | x::xs' ->
%        f x && for_all f xs'
%
%let rec check x = x >= 0
%
%let rec make_list n =
%  if n < 0
%  then []
%  else n :: make_list (n-1)
%
%let main n = assert (for_all check (make_list n))
%\end{alltt}
%
%\item isnil
%\begin{alltt}
%let is_nil (xs:int list) =
%  match xs with
%      [] -> true
%    | _ -> false
%
%let rec make_list n =
%  if n = 0
%  then []
%  else n :: make_list (n-1)
%
%let main n =
%  let xs = make_list n in
%    if n > 0
%    then assert (not (is_nil xs))
%    else ()
%\end{alltt}
%
%\item iter
%\begin{alltt}
%let rec iter (f:int -> unit) xs =
%  match xs with
%      [] -> ()
%    | x::xs' -> f x; iter f xs'
%
%let rec make_list n =
%  if n < 0
%  then []
%  else n :: make_list (n-1)
%
%let check x = assert (x >= 0)
%
%let main n =
%  let xs = make_list n in
%    iter check xs
%\end{alltt}
%
%\item length3
%\begin{alltt}
%let rec length (xs:int list) =
%  match xs with
%      [] -> 0
%    | _::xs' -> 1 + length xs'
%
%let rec make_list n =
%  if n = 0
%  then []
%  else n :: make_list (n-1)
%
%let main n =
%  let xs = make_list n in
%    assert (length xs = n)
%\end{alltt}
%
%\item mem
%\begin{alltt}
%let rec mem (x:int) xs =
%  match xs with
%      [] -> false
%    | x'::xs -> x = x' || mem x xs
%
%let rec make_list n (x:int) =
%  if n < 0
%  then []
%  else x :: make_list (n-1) x
%
%let is_nil (xs:int list) =
%  match xs with
%      [] -> true
%    | _ -> false
%
%let main n m =
%  let xs = make_list n m in
%    assert (is_nil xs || mem m xs)
%\end{alltt}
%
%\item nth0
%\begin{alltt}
%let is_nil (xs:int list) =
%  match xs with
%      [] -> true
%    | _ -> false
%
%let rec nth n (xs:int list) =
%  match xs with
%    | [] -> assert false
%    | x::xs' -> if n = 0 then x else nth (n-1) xs'
%
%let rec make_list n =
%  if n < 0
%  then []
%  else n :: make_list (n-1)
%
%let main n =
%  let xs = make_list n in
%    if is_nil xs
%    then 0
%    else nth 0 xs
%\end{alltt}
%
%\item harmonic
%\begin{alltt}
%let rec div x y =
%  assert (y <> 0);
%  if x < y
%  then 0
%  else 1 + div (x-y) y
%
%let rec fold_left (f:int->int->int) acc xs =
%  match xs with
%      [] -> acc
%    | x::xs' -> fold_left f (f acc x) xs'
%
%let rec range i j =
%  if i > j then
%    []
%  else
%    let is = range (i+1) j in
%      i::is
%
%let harmonic n =
%  let ds = range 1 n in
%    fold_left (fun s k -> s + div 10000 k) 0 ds
%\end{alltt}
%
%\item fold\_left
%\begin{alltt}
%let rec fold_left (f:int->int->int) acc xs =
%  match xs with
%      [] -> acc
%    | x::xs' -> fold_left f (f acc x) xs'
%
%let rec make_list n =
%  if n < 0
%  then []
%  else n :: make_list (n-1)
%
%let add x y = x + y
%
%let main n m =
%  let xs = make_list n in
%    assert (fold_left add m xs >= m)
%\end{alltt}
%
%\item iter\_fun\_list
%\begin{alltt}
%let rec iter (f:(int->unit)->unit) xs =
%  match xs with
%      [] -> ()
%    | x::xs' -> f x; iter f xs'
%
%let rec make_list n =
%  if n < 0
%  then []
%  else (fun x -> assert (n >= x)) :: make_list (n-1)
%
%let main n =
%  let xs = make_list n in
%    iter (fun f -> f 0) xs
%\end{alltt}
%
%
%\item map
%\begin{alltt}
%let rec map f xs =
%  match xs with
%      [] -> []
%    | x::xs' -> f x :: map f xs'
%
%let rec length xs =
%  match xs with
%      [] -> 0
%    | _::xs' -> 1 + length xs'
%
%let rec make_list n =
%  if n < 0
%  then []
%  else n :: make_list (n-1)
%
%let succ x = x + 1
%
%let main n =
%  let xs = make_list n in
%  let xs' = map succ xs in
%    assert (length xs = length xs')
%\end{alltt}
%
%\item zip
%\begin{alltt}
%let rec zip xs ys =
%  match xs with
%      [] ->
%        begin
%          match ys with
%              [] -> []
%            | _ -> assert false
%        end
%    | x::xs' ->
%        match ys with
%            [] -> assert false
%          | y::ys' -> (x,y)::zip xs' ys'
%
%let rec make_list n =
%  if n < 0
%  then []
%  else n :: make_list (n-1)
%
%let main n =
%  let xs = make_list n in
%    zip xs xs
%\end{alltt}
%
%\item inits
%\begin{alltt}
%let rec make_list m =
%  if m <= 0
%  then []
%  else Random.int 0 :: make_list (m-1)
%
%let rec make_list_list m =
%  if m <=0
%  then []
%  else make_list (Random.int 0) :: make_list_list (m-1)
%
%let head = function
%    [] -> assert false
%  | x::xs -> x
%
%let ne = function
%    [] -> 0
%  | x::xs -> 1
%
%let rec filter p = function
%    [] -> []
%  | x::xs -> if p x = 1 then x::(filter p xs) else filter p xs
%
%let rec map f = function
%    [] -> []
%  | x::xs -> f x :: map f xs
%
%let main m = map head (filter ne (make_list_list m))
%\end{alltt}
%
%\end{itemize}
