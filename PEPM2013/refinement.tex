\input{macro}

\section{Predicate Discovery}

In this section, we propose a new predicate discovery method for 
higher-order programs.  The method is an extension of our previous one 
used in MoCHi~\cite{KobayashiPLDI2011}, which we briefly overview below.

In MoCHi, predicates for abstracting each term of a given program are 
specified as a kind of dependent types called abstraction types.  MoCHi 
infers abstraction types automatically in a counterexample-guided manner. 
 From an error path of an abstracted program (returned as a result of 
higher-order model checking), MoCHi generates a straightline 
higher-order program (SHP) which is safe if and only if the error path 
is infeasible.  If the path is actually infeasible, MoCHi uses an 
existing method~\cite{Unno2009} to infer refinement types that witness 
the safety of the SHP.  Finally, MoCHi extracts abstraction types from 
the refinement types.  The abstraction types contain sufficient enough 
predicates for refuting the infeasible error path.

In our new method, we reuse the above framework for abstraction type 
inference but extend the submodule for refinement type 
inference~\cite{Unno2009} so that it can consider information from 
multiple calling contexts in multiple SHPs to infer a general refinement 
type that type-checks the multiple calling contexts, while preserving 
path- and context- sensitivity.  Our method consists of two steps: 
constraint generation and solving, which are respectively explained in 
Sections~\ref{sec:cg} and \ref{sec:cs}.

\subsection{Constraint Generation}
\label{sec:cg}

%%%\begin{figure*}[tbh]
%%%\begin{eqnarray*}
%%%\CG{\Gamma}{x}
%%%&=&(\reftype{u}{u = x},\top) \quad (\mbox{if}~\sty{x}=\inttype) \\
%%%\CG{\Gamma}{\kappa}
%%%&=&(\Gamma(\kappa),\top) \quad (\mbox{if}~\sty{\kappa} \in \rightarrow) \\
%%%\CG{\Gamma}{c}
%%%&=&(\cty{c},\top) \\
%%%\CG{\Gamma}{\ttlet{x}{e_1}{e_2}}
%%%&=&\mbox{let~}(\sigma,\theta_1)=\CG{\Gamma}{e_1} \\
%%%& &\mbox{let~}(\cpstype,\theta_2)=\CG{\Gamma,x\smallcolon\sigma}{e_2} \\
%%%& &(\cpstype,\theta_1 \land \theta_2) \\
%%%\CG{\Gamma}{\ttapp{e}{x}}
%%%&=&\mbox{let~}(\funtype{y}{\sigma}{\tau},\theta_1)=\CG{\Gamma}{e} \\
%%%& &\mbox{let~}(\sigma',\theta_2)=\CG{\Gamma}{x} \\
%%%& &(\tau[x/y],\theta_1 \land \theta_2 \land \CS{\Gamma}{\sigma'}{\sigma}) \\
%%%\CG{\Gamma}{\ttifndet{e_1}{e_2}}
%%%&=&\mbox{let~}(\cpstype,\theta_1)=\CG{\Gamma}{e_1} \\
%%%& &\mbox{let~}(\cpstype,\theta_2)=\CG{\Gamma}{e_2} \\
%%%& &(\cpstype,\theta_1 \land \theta_2) \\
%%%\CS{\Gamma}{\cpstype}{\cpstype}
%%%&=&\top \\
%%%\CS{\Gamma}{\funtype{x}{\sigma_1}{\tau_1}}{\funtype{x}{\sigma_2}{\tau_2}}
%%%&=&\CS{\Gamma}{\sigma_2}{\sigma_1} \land \CS{\Gamma,x:\sigma_2}{\tau_1}{\tau_2} \\
%%%\CS{\Gamma}{\reftype{u}{\theta_1}}{\reftype{u}{\theta_2}}
%%%&=&\forall u.(\sembrack{\Gamma} \wedge \theta_1) \Rightarrow \theta_2  \quad (\mbox{if}~u \notin \free{\sembrack{\Gamma}})
%%%\end{eqnarray*}
%%%\caption{Constraint generation algorithm.}
%%%\label{fig:cgen}
%%%\end{figure*}

In this section, we extend a constraint generation algorithm used in 
previous work~\cite{Unno2009,Terauchi2010,KobayashiPLDI2011}.  Thus, we 
first briefly overview the previous algorithm.  Let us assume that we 
are given a SHP \(d\) which is typable if and only if the abstract error 
trace is infeasible.  From \(d\), we generate Horn-clause-like 
constraints which are satisfiable if and only if \(d\) is typable.  To 
this end, for each function, we prepare a refinement type template with 
predicate variables, which act as placeholders of refinement predicates 
to be inferred.  We then generate a typing derivation of \(d\) under the 
type environment that associates each function with its type template.  
Horn-clause-like constraints on the predicate variables are then 
extracted from the derivation.  Since the SHP $d$ is recursion-free and 
linear (i.e., each function is called exactly once), generated 
constraints are non-recursive.  \todo{examples}

We extend the above algorithm as follows.
\begin{itemize}
\item Instead of a single infeasible error path, we consider multiple 
paths for predicate discovery:  we keep the set 
\(\set{\pi_1,\dot,\pi_n}\) of infeasible error paths found so far, 
generate the set \(C_i\) of Horn clauses for each path \(\pi_i\), and 
use \(C_1 \cup \dots \cup C_n\) for predicate discovery.
\item In addition to generating Horn-clause-like constraints, we obtain 
an equivalence relation \(E\) on the predicate variables such that \(P\ 
E\ Q\) if and only if the predicate variables \(P\) and \(Q\) represent 
(possibly different) refinement predicates for the same argument of the 
same function in the original program.  \todo{an example}  The 
equivalence relation \(E\) is used to find general solutions for the 
constraints.
\end{itemize}

%%%
%%%We then use the constraint generation algorithm for terms defined in 
%%%Figure~\ref{fig:cgen} to obtain constraints.  In the figure, 
%%%$\CG{\Gamma}{e}$ returns a pair of a refinement type $\tau$ and a 
%%%constraint $\theta$ such that $\Gamma \vdash e : \tau$ is derivable if 
%%%and only if $\theta$ is valid. Similarly, $\CS{\Gamma}{\tau_1}{\tau_2}$ 
%%%returns a constraint $\theta$ such that $\Gamma \vdash \tau_1 \leq 
%%%\tau_2$ is derivable if and only if $\theta$ is valid.
%%%%
%%%The algorithm is almost a straightforward modification of the typing and 
%%%subtyping rules in Section~\ref{sec:reftypesystem} except that the 
%%%application of the subsumption rule is restricted to the acutal argument 
%%%of function applications.




\subsection{Constraint Solving}
\label{sec:cs}

\todo{explain a high-level idea of the algorithm.} The constraint 
solving proceeds as follows.  First, we compute the lower \(\lambda 
\seq{x}.\phi_P\) and the upper \(\lambda \seq{x}.\phi_P'\) bounds for 
each predicate variable \(P\) in the constraints (where \(\FV{\phi_P} 
\subseteq \set{\seq{x}}\) and \(\FV{\phi_P'} \subseteq \set{\seq{x}}\)). 
 The computation of the upper bound for some predicate variable may 
possibly fail because \todo{}.  Let \(S\) be the set of predicate 
variables whose upper bounds were successfully computed.  We then pick 
an equivalence class \(S_0 \in S / E\) (e.g., the largest one), and find 
\(S_1\dots,S_n\) such that:
\begin{itemize}
\item \(S_0 = S_1 \cup \dots \cup S_n\),
\item for each \(i \in \set{1,\dots,n}\), if \(S_i = 
\set{Q_1,\dots,Q_{\ell}}\), then \(\phi_{Q_1} \lor \dots \lor 
\phi_{Q_{\ell}}\) implies \(\phi_{Q_1}' \land \dots \land 
\phi_{Q_{\ell}}'\), and
\item for any \(i,j \in \set{1,\dots,n}\), if \(i \neq j\) and 
\(S_i \cup S_j = \set{Q_1,\dots,Q_{\ell}}\), then \(\phi_{Q_1} \lor 
\dots \lor \phi_{Q_{\ell}}\) does not imply \(\phi_{Q_1}' \land \dots 
\land \phi_{Q_{\ell}}'\).
\end{itemize}
We then pick some \(S_i = \set{Q_1,\dots,Q_{\ell}}\) (e.g., the largest 
one) and find a formula \(\phi\) such that:
\begin{itemize}
\item \(\phi_{Q_1} \lor \dots \lor \phi_{Q_{\ell}}\) implies \(\phi\),
\item \(\phi\) implies \(\phi_{Q_1}' \land \dots \land \phi_{Q_{\ell}}'\), and
\item \(\FV{\phi} \subseteq \set{\seq{x}}\).
\end{itemize}
%Terauchi2010
The problem of finding such a formula \(\phi\) is a well-known logical 
interpolation problem~\cite{}.  In other words, such a formula \(\phi\) 
is obtained as an interpolant \(\mathcal{I}(\phi_{Q_1} \lor \dots \lor 
\phi_{Q_{\ell}},\phi_{Q_1}' \land \dots \land \phi_{Q_{\ell}}')\), where 
an interpolant \(\mathcal{I}(\phi_1,\phi_2)\) of \(\phi_1\) and 
\(\phi_2\) (such that \(\phi_1\) implies \(\phi_2\)) is a formula 
\(\phi\) that satisfies the following conditions:
\begin{itemize}
\item \(\phi_1\) implies \(\phi\),
\item \(\phi\) implies \(\phi_2\), and
\item \(\FV{\phi} \subseteq \FV{\phi_1} \cap \FV{\phi_2}\).
\end{itemize}
However, the conditions for interpolants are not sufficient for our 
purpose: we want to obtain as simple interpolant as possible with 
respect to the number of disjunctions and conjunctions.  To this end, we 
propose a new operator \(\mathcal{J}\) that combines the convex 
hull~\cite{} and the logical interpolation~\cite{} \(\mathcal{I}\) 
operators~\footnote{\todo{explain interpolant is not unique}}.  Let us 
write \(\mathcal{H}(\phi)\) to denote the convex hull of \(\phi\).  
Given \(\phi_1\) and \(\phi_2\) such that \(\phi_1\) implies \(\phi_2\), 
the new operator \(\mathcal{J}(\phi_1,\phi_2)\) is defined as follows:
\begin{eqnarray*}
\mathcal{J}(\phi_1,\phi_2) =
\left\{
\begin{array}{ll}
\mathcal{I}(\mathcal{H}(\phi_1),\neg \mathcal{H}(\neg \phi_2)) & (\mbox{if~}\mathcal{H}(\phi_1) \Rightarrow \neg \mathcal{H}(\neg \phi_2)) \\
\mathcal{I}(\phi_1,\phi_2) & (\mbox{otherwise})
\end{array}
\right.
\end{eqnarray*}
\todo{explain why it works better in most cases}

%%%The refinement type inference method~\cite{Unno2009} relies on a 
%%%technique called interpolation~\cite{Henzinger2004,McMillan2005} from 
%%%automated theorem proving to infer a refinement type of each 
%%%subexpression \(e\) of an ordinary ML type \(\tau\):  The method first 
%%%computes the strongest condition \(\phi_{post}\) on the value \(\nu\) of 
%%%\(e\) and the weakest condition \(\phi_{pre}\) on the value \(\nu\) 
%%%which is required by the context of \(e\).  The method then computes an 
%%%interpolant \(\phi\) of \(\phi_{post}\) and \(\phi_{pre}\), and returns 
%%%\(\set{\nu:\tau \mid \phi}\) as a refinement type of \(e\).
%
%%%%Thus, the method considers both forward and backward information of \(e\) 
%%%%respectively obtained from \(e\) and the context of \(e\).
