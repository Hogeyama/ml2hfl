\subsection{Selective CPS transformation}
\label{sec:CPS}

This section formalizes selective CPS transformation for abstracted
programs.  As stated in Sect.~\ref{sec:intro}, the idea for selective CPS
transformation is to distinguish whether a continuation parameter should
be inserted to each function or not.  When a function application has
side-effects, we need not insert continuations in CPS transformation.
Here, $\FAIL$, nondeterministic branch, and non-termination are
considered as side-effects in abstracted program.
%For example, since an
%application of function $\Abs{x}{\Abs{y}{\Assert{x+y}}}$ to a value has
%no side-effects, it can be transformed to CPS by inserting only one
%continuation like $\Abs{x}{\Abs{y}{\Abs{k}{\App{k}{(x+y)}}}}$ instead of
%$\Abs{x}{\Abs{k}{\App{k}{(\Abs{y}{\Abs{k'}{\App{k'}{(x+y)}}})}}}$.

Note that a similar approach has proposed by Nielsen~\cite{Nielsen2001}.
Generated programs by their transformation, however, do not yield the
same results under a call-by-value semantics and a call-by-name
semantics.  To be more precise, the transformation does not treat
non-termination as a side-effect.  The transformation does not fit our
purpose of translating call-by-value programs into equivalent
call-by-name programs.

To distinguish whether we should insert a continuation or not, we
annotate a label $l \in \{\NC,\IC\}$ to each function type like
$\TFunL{l}{\tau_1}{\tau_2}$ .  A type $\TFunC{\tau_1}{\tau_2}$ means
that we should insert a continuation, and $\TFunN{\tau_1}{\tau_2}$ means
not.

%\begin{example}[Selective CPS Transformation]
%Consider the following program.
%\begin{alltt}
%let apply = \(\lambda\)x.\(\lambda\)f. f x
%let check = \(\lambda\)x.\(\lambda\)y. assert (x = y)
%let main = \(\lambda\)n. apply n (check n)
%\end{alltt}
%We can translated this program into the following program by na\"{\i}ve CPS transformation.
%\begin{alltt}
%let apply = \(\lambda\)x.\(\lambda\)k1. k1 (\(\lambda\)f.\(\lambda\)k2. f x k2)
%let check = \(\lambda\)x.\(\lambda\)k1. k1 (\(\lambda\)y.\(\lambda\)k2. assert (x = y); k2 ())
%let main = \(\lambda\)n.\(\lambda\)k. check n (\(\lambda\)f1. apply n (\(\lambda\)f2. f2 f1 k))
%\end{alltt}
%The order of this program is \emph{fifth}, i.e. the order of \texttt{apply}.
%%\mathtt{apply}\COL\TFun{\INT}{\TFun{(\TFun{(\TFun{(\TFun{\INT}{\TFun{(\TFun{\INT}{\UNIT})}{\UNIT}})}{\TFun{(\TFun{\INT}{\UNIT})}{\UNIT}})}{\UNIT})}{\UNIT}}
%On the other hand, considering the following annotated program,
%\begin{alltt}
%let apply = \(\lambda\sp{\NC}\)x.\(\lambda\sp{\IC}\)f. f x
%let check = \(\lambda\sp{\IC}\)x.\(\lambda\sp{\IC}\)y. assert (x = y)
%let main = \(\lambda\sp{\IC}\)n. apply n (check n)
%\end{alltt}
%we can translate the program into the following \emph{third} order CPS program.
%\begin{alltt}
%let apply = \(\lambda\)x.\(\lambda\)f.\(\lambda\)k. f x k
%let check = \(\lambda\)x.\(\lambda\)k1. = k1 (\(\lambda\)y.\(\lambda\)k. assert (x = y); k ())
%let main = \(\lambda\)n.\(\lambda\)k. check n (\(\lambda\)f. apply n f k)
%\end{alltt}
%\end{example}

%We used the model checker TRecS in our previous verifier.  Described in
%Section~\ref{model-check}, since TRecS is a model checker for
%higher-order recursion scheme, we need CPS transformation to apply TRecS
%to call-by-value programs.  A na\"{\i}ve CPS transformation, however,
%becomes programs complicate and higher-order.
%
%A selective CPS transformation is a CPS transformation that only
%transforms functions with side effects.

We first define the source language of selective CPS transformation.
The language is the same as the source language except that: (i) the set
of terms is extended with non-deterministic branch $\Br{t_1}{t_2}$, (ii)
a label $l \in \{\NC,\IC\}$ is annotated to each function type like
$\TFunL{l}{\tau_1}{\tau_2}$.

%\begin{eqnarray*}
% t\text{ (terms)} &::=& \cdots \mid \AbsT{x}{\tau}{t} \mid \AbsTC{x}{\tau}{t} \\
% v\text{ (values)} &::=& \cdots \mid \AbsT{x}{\tau}{t} \mid \AbsTC{x}{\tau}{t} \\
% \tau\text{ (types)} &::=& \cdots \mid \TFunC{\tau_1}{\tau_2}
%\end{eqnarray*}

Below, we formalize the selective CPS as a type-based transformation.
Figure~\ref{fig:cps} shows the rules of the selective CPS
transformation.  The relation $\CPS{\Gamma}{t}{\tau}{l}{t'}$ reads that
a term $t$ is translated to a term $t'$ by using a type $\tau$, under
the assumption that each free variable x of $t$ has been transformed
using the type $\Gamma(x)$.
%Here, $\MAbs{x}{t}$ and
%$\MApp{t_1}{t_2}$ are, respectively, application and abstraction that
%will be reduced statically in the translation.

\begin{figure}[htbp]
\begin{minipage}{\textwidth}
\infax[CPS-Const]
 {\CPS{\Gamma}{n}{\INT}{\NC}{n}}

\medskip

\infax[CPS-Var]
 {\CPS{\Gamma,x\COL\tau}{x}{\tau}{\NC}{x}}

\medskip

\infax[CPS-Op]
 {\CPS{\Gamma}{\Op{v_1,\dots,v_n}}{\INT}{\NC}{\Op{v_1,\dots,v_n}}}

\medskip

\infrule[CPS-AbsN]
 {\CPS{\Gamma, x\COL\tau_1}{t}{\tau_2}{\NC}{t'}}
 {\CPS{\Gamma}{\Abs{x}{t}}{\TFunN{\tau_1}{\tau_2}}{\NC}{\Abs{x}{t'}}}

\medskip

\infrule[CPS-AbsC]
 {\CPS{\Gamma, x\COL\tau_1}{t}{\tau_2}{l}{t'}}
 {\CPS{\Gamma}{\Abs{x}{t}}{\TFunL{C}{\tau_1}{\tau_2}}{\NC}
  {\Abs{x}{\Abs{k}{\SApp{l}{t'}{k}}}}}

\medskip

\infrule[CPS-AppN]
 {\CPS{\Gamma}{t_0}{\TFunN{\tau_1}{\tau}}{\NC}{t_0'} \andalso
  \CPS{\Gamma}{t_1}{\tau_1}{\NC}{t_1'}}
 {\CPS{\Gamma}{\App{t_0}{t_1}}{\tau}{\NC}
  {\App{t_0'}{t_1'}}}

\medskip

\infrule[CPS-AppC]
 {\CPS{\Gamma}{t_0}{\TFunL{l}{\tau_1}{\tau}}{l_0}{t_0'} \andalso
  \CPS{\Gamma}{t_1}{\tau_1}{l_1}{t_1'}}
 {\CPS{\Gamma}{\App{t_0}{t_1}}{\tau}{\IC}
  {\Abs{k}{\SApp{l_0}{t_0'}{\Abs{x_0}{\SApp{l_1}{t_1'}{\Abs{x_1}{\SApp{l}{\App{x_0}{x_1}}{k}}}}}}}}

%\medskip
%
%\infrule[CPS-AppN]
% {\CPS{\Gamma}{t_0}{\TFunN{\tau_1}{\TFunN{\cdots}{\TFunN{\tau_n}{\tau}}}}{\NC}{t_0'} \andalso
%  \CPS{\Gamma}{t_i}{\tau_i}{\NC}{t_i'} \quad \text{for each $i \in \set{1,\dots,n}$}}
% {\CPS{\Gamma}{\App{\App{\App{t_0}{t_1}}{\dots}}{t_n}}{\tau}{\NC}
%  {\App{\App{\App{t_0'}{t_1'}}{\ldots}}{t_n'}}}
%
%\medskip
%
%\infrule[CPS-AppC]
% {\CPS{\Gamma}{t_0}{\TFunL{l_1}{\tau_1}{\TFunL{l_{n-1}}{\cdots}{\TFunL{l_n}{\tau_n}{\tau}}}}{l_0}{t_0'} \andalso
%  \CPS{\Gamma}{t_i}{\tau_i}{l_i}{t_i'} \quad \text{for each $i \in \set{1,\dots,n}$}}
% {\CPS{\Gamma}{\App{\App{\App{t_0}{t_1}}{\dots}}{t_n}}{\tau}{\IC}
%  {\Abs{k}{\SApp{l_0}{t_0'}{\Abs{x_0}{\SApp{l_1}{t_1'}{\Abs{x_1}{\cdots\SApp{l_n}{t_n'}{\Abs{x_n}{\App{\App{\App{\App{x_0}{x_1}}{\ldots}}{x_n}}{k}}}\cdots}}}}}}}
%
\medskip

\infax[CPS-Fail]
 {\CPS{\Gamma}{\FAIL}{\tau}{\IC}{\Abs{k}{\FAIL}}}

\medskip

\infrule[CPS-IfN]
 {\CPS{\Gamma}{t_1}{\INT}{\NC}{t_1'} \andalso
  \CPS{\Gamma}{t_2}{\tau}{\NC}{t_2'} \andalso
  \CPS{\Gamma}{t_3}{\tau}{\NC}{t_3'}}
 {\CPS{\Gamma}{\If{t_1}{t_2}{t_3}}{\tau}{\NC}
  {\If{t_1'}{t_2'}{t_3'}}}

\medskip

\infrule[CPS-IfC]
 {\CPS{\Gamma}{t_1}{\INT}{l_1}{t_1'} \andalso
  \CPS{\Gamma}{t_2}{\tau}{l_2}{t_2'} \andalso
  \CPS{\Gamma}{t_3}{\tau}{l_3}{t_3'}}
 {\CPS{\Gamma}{\If{t_1}{t_2}{t_3}}{\tau}{\IC}
  {\Abs{k}{\SApp{l_1}{t_1}{\Abs{m}{\If{m}{\SApp{l_2}{t_2'}{k}}{\SApp{l_3}{t_3'}{k}}}}}}}

\medskip

\infrule[CPS-Br]
 {\CPS{\Gamma}{t_1}{\tau}{l_1}{t_1'} \andalso
  \CPS{\Gamma}{t_2}{\tau}{l_2}{t_2'}}
 {\CPS{\Gamma}{\Br{t_1}{t_2}}{\tau}{\IC}
  {\Abs{k}{\If{\Br{0}{1}}{\SApp{l_1}{t_2'}{k}}{\SApp{l_2}{t_3'}{k}}}}}

\medskip

\infrule[CPS-Prog]
 {\Gamma(f_i) \text{ is of the form } \TFunC{\tau_{i1}}{\TFunC{\tau_{i2}}{\TFunC{\cdots}{\tau_{ik_i}}}} \\
  \CPS{\Gamma}{v_i}{\Gamma(f_i)}{\NC}{v_i'} \quad \text{for each $i \in \set{1,\dots,n}$}}
 {\CPSprog{\Gamma}{\{f_1=v_1,\dots,f_n=v_n\}}{\{f_1=v_1',\dots,f_n=v_n'\}}}

\begin{eqnarray*}
 \SApp{\NC}{t}{k} &=& \App{k}{t} \\
 \SApp{\IC}{t}{k} &=& \App{t}{k}
\end{eqnarray*}

\end{minipage}
\caption{Selective CPS transformatation}
\label{fig:cps}
\end{figure}

%\begin{figure}[htbp]
%\begin{minipage}{\textwidth}
%\infax[CPS-Const]
% {\CPS{\Gamma}{n}{\INT}{\NC}{\Abs{\kappa}{\App{\kappa}{n}}}}
%
%\medskip
%
%\infax[CPS-Var]
% {\CPS{\Gamma,x\COL\tau}{x}{\tau}{\NC}{\Abs{\kappa}{\App{\kappa}{x}}}}
%
%\medskip
%
%\infax[CPS-Op]
% {\CPS{\Gamma}{\Op{v_1,\dots,v_n}}{\INT}{\NC}{\Abs{\kappa}{\App{\kappa}{(\Op{v_1,\dots,v_n})}}}}
%
%\medskip
%
%\infrule[CPS-AbsN]
% {\CPS{\Gamma, x\COL\tau_1}{t}{\tau_2}{\NC}{t'}}
% {\CPS{\Gamma}{\Abs{x}{t}}{\TFunN{\tau_1}{\tau_2}}{\NC}
%  {\Abs{\kappa}{\Abs{x}{\App{t'}{(\Abs{m}{\App{\kappa}{m}})}}}}}
%
%\medskip
%
%\infrule[CPS-AbsC]
% {\CPS{\Gamma, x\COL\tau_1}{t}{\tau_2}{\IC}{t'}}
% {\CPS{\Gamma}{\Abs{x}{t}}{\TFunC{\tau_1}{\tau_2}}{\NC}
%  {\Abs{\kappa}{\App{\kappa}{(\Abs{x}{\Abs{k}{\App{t'}{(\Abs{m}{\App{k}{m}})}}})}}}}
%
%\medskip
%
%\infrule[CPS-AppN]
% {\text{$t_0$ is not of the form $\App{\App{\App{f}{t_{00}}}{\ldots}}{t_{0k}}$} \\
%  \CPS{\Gamma}{t_0}{\TFunN{\tau_1}{\TFunN{\cdots}{\TFunN{\tau_n}{\tau}}}}{\NC}{t_0'} \andalso
%  \CPS{\Gamma}{t_i}{\tau_i}{\NC}{t_i'} \quad \text{for each $i \in \set{1,\dots,n}$}}
% {\CPS{\Gamma}{\App{\App{\App{t_0}{t_1}}{\dots}}{t_n}}{\tau}{\NC}
%  {\Abs{\kappa}{\App{\kappa}{(\App{t_0'}{(\Abs{x_0}{\App{t_1'}{(\Abs{x_1}{\cdots(\Abs{x_n}{\App{\App{\App{x_0}{x_1}}{\ldots}}{x_n}})\cdots})}})})}}}}
%
%\medskip
%
%\infrule[CPS-AppC]
% {\CPS{\Gamma}{t_0}{\TFunL{l_1}{\tau_1}{\TFunL{l_{n-1}}{\cdots}{\TFunC{\tau_n}{\tau}}}}{l}{t_0'} \andalso
%  \CPS{\Gamma}{t_i}{\tau_i}{l_i'}{t_i'} \quad \text{for each $i \in \set{1,\dots,n}$}}
% {\CPS{\Gamma}{\App{\App{\App{t_0}{t_1}}{\dots}}{t_n}}{\tau}{\IC}
%  {\Abs{\kappa}{\App{t_0'}{(\Abs{x_0}{\App{t_1'}{(\Abs{x_1}{\cdots(\Abs{x_n}{\App{\App{\App{\App{x_0}{x_1}}{\ldots}}{x_n}}{(\Abs{r}{\App{\kappa}{r}})}})\cdots})}})}}}}
%
%\medskip
%
%\infax[CPS-Fail]
% {\CPS{\Gamma}{\FAIL}{\tau}{\IC}{\Abs{\kappa}{\FAIL}}}
%
%\medskip
%
%\infrule[CPS-If]
% {\CPS{\Gamma}{t_1}{\INT}{l}{t_1'} \andalso
%  \CPS{\Gamma}{t_2}{\tau}{l}{t_2'} \andalso
%  \CPS{\Gamma}{t_3}{\tau}{l}{t_3'}}
% {\CPS{\Gamma}{\If{t_1}{t_2}{t_3}}{\tau}{l}
%  {\Abs{\kappa}{\App{t_1}{(\Abs{m}{\If{m}{\App{t_2'}{\kappa}}{\App{t_3'}{\kappa}}})}}}}
%
%\medskip
%
%\infrule[CPS-Br]
% {\CPS{\Gamma}{t_1}{\tau}{l_1}{t_1'} \andalso
%  \CPS{\Gamma}{t_2}{\tau}{l_2}{t_2'}}
% {\CPS{\Gamma}{\Br{t_1}{t_2}}{\tau}{\IC}
%  {\Abs{\kappa}{\If{\Br{0}{1}}{\App{t_2'}{\kappa}}{\App{t_3'}{\kappa}}}}}
%
%\medskip
%
%\infrule[CPS-Prog]
% {\CPS{\Gamma}{v_i}{\Gamma(f_i)}{\NC}{v_i'} \quad \text{for each $i \in \set{1,\dots,n}$}}
% {\CPSprog{\Gamma}{\{f_1=v_1,\dots,f_n=v_n\}}{\{f_1=\App{v_1}{(\Abs{m}{m})},\dots,f_n=\App{v_n}{(\Abs{m}{m})}\}}}
%
%%\begin{eqnarray*}
%% \CPSty{b} &=& b \\
%% \CPSty{\TFunC{\tau_1}{\tau_2}} &=& \TFun{\CPSty{\tau_1}}{\TFun{(\TFun{\CPSty{\tau_2}}{\UNIT})}{\UNIT}} \\
%% \CPSty{\TFun{\tau_1}{\tau_2}} &=& \TFun{\CPSty{\tau_1}}{\CPSty{\tau_2}}
%%\end{eqnarray*}
%\end{minipage}
%\caption{Selective CPS transformatation}
%\label{fig:cps}
%\end{figure}

In the rule \rn{CPS-AbsC}, a term $\Abs{x}{t}$ is transformed in a
standard way, i.e. a continuation parameter $k$ is inserted and $t'$,
the CPS version of $t$, applies to $k$.  On the other hand, in the rule
\rn{CPS-AbsN}, no continuation parameter is inserted and direct style is
preserved.  The rules for applications are similar. In the rule
\rn{CPS-AppC}, a continuation is inserted, but not in the rule
\rn{CPS-AppN}.  These rule expresses the intuition that a term which has
a type of the form $\TFunC{\tau_1}{\tau_2}$ should insert a
continuation.  The rules are designed in such a way that transformed
term $t'$ has type $\CPSty{\tau}$ if $\CPS{\Gamma}{t}{\tau}{N}{t'}$
holds, and transformed term $t'$ has type
$\TFun{(\TFun{\CPSty{\tau}}{\AT})}{\AT}$ if
$\CPS{\Gamma}{t}{\tau}{C}{t'}$ holds, where $\AT$ is the answer type and
$\CPSty{\tau}$ is defined as follows.
\begin{eqnarray*}
 \CPSty{\INT} &=& \INT \\
 \CPSty{\TFunN{\tau_1}{\tau_2}} &=& \TFun{\CPSty{\tau_1}}{\CPSty{\tau_2}} \\
 \CPSty{\TFunC{\tau_1}{\tau_2}} &=& \TFun{\CPSty{\tau_1}}{\TFun{(\TFun{\CPSty{\tau_2}}{\AT})}{\AT}}
\end{eqnarray*}

Figure~\ref{fig:cps-example} shows examples of selective CPS
transformation.  The examples are the transformations of
\texttt{$\lambda$x.$\lambda$y.assert (x = y)}.

{
\def\check{\mathtt{check}}
\def\apply{\mathtt{apply}}
\def\assert{\mathtt{assert}}
\def\assertcps{\mathtt{assert}_\mathtt{CPS}}
\def\k{\mathtt{k}}
\def\n{\mathtt{n}}
\def\f{\mathtt{f}}
\def\x{\mathtt{x}}
\def\y{\mathtt{y}}
\def\eq{\mathtt{=}}
\def\App#1#2{{#1}~{#2}}
\begin{figure}[htbp]
\begin{minipage}{\textwidth}
\infer{
e \CPS{\Gamma}
     {\Abs{x}{\Abs{y}{\assert(x = y)}}}
     {\TFunN{\INT}{\TFunC{\INT}{\INT}}}{\NC}
     {\Abs{\kappa}{\Abs{x}{\App{\kappa}{(\Abs{y}{\Abs{k}{\App{\App{\assert}{(x=y)}}{k}}})}}}}
}{
\infer{
 \CPS{\Gamma_x}
     {\Abs{y}{\App{\assert}{(x = y)}}}
     {\TFunC{\INT}{\INT}}{\NC}
     {\Abs{\kappa}{\App{\kappa}{(\Abs{y}{\Abs{k}{\App{\App{\assert}{(x=y)}}{k}}})}}}
}{
\infer{
 \CPS{\Gamma_{xy}}
     {\App{\assert}{(x = y)}}
     {\INT}{\IC}
     {\Abs{\kappa}{\App{\App{\assert}{(x=y)}}{k}}}
}{
 \CPS{\Gamma_{xy}}{\assert}{\TFunC{\INT}{\INT}}{\NC}{\Abs{\kappa}{\App{\kappa}{\assert}}}
  &
 \infer{\CPS{\Gamma_{xy}}{x=y}{\INT}{\NC}{\Abs{\kappa}{\App{\kappa}{(x=y)}}}}{\vdots}
}}}
(a)

\infer{
 \CPS{\Gamma}
     {\Abs{x}{\Abs{y}{\assert(x = y)}}}
     {\TFunC{\INT}{\TFunC{\INT}{\INT}}}{\NC}
     {}
}{
\infer{
 \CPS{\Gamma_x}
     {\Abs{y}{\App{\assert}{(x = y)}}}
     {\TFunC{\INT}{\INT}}{\IC}
     {\Abs{\kappa}{\App{\kappa}{(\Abs{y}{\Abs{k}{\App{\App{\assert}{(x=y)}}{k}}})}}}
}{\vdots}}
(b)
\end{minipage}
\caption{Transformation of $\AbsC{x}{\AbsC{y}{\assert(x = y)}}$. ($\Gamma_x=\Gamma,x\COL\INT$ and $\Gamma_{xy}=\Gamma_x,y\COL\INT$)}
\label{fig:cps-example}
\end{figure}
}

In the following, we discuss the properties of selective CPS transformation.
The theorem below shows that we can transform arbitrary simply-typed programs into CPS.
\begin{theorem}
If $D$ is simply-typed, then there exists $D'$ such that $\CPSprog{\Gamma}{D}{D'}$.
\end{theorem}
The following theorem states the correctness of the selective CPS
transformation, in the sense that the transformed program is reduced to
the same value as original program.
\begin{theorem}[Correctness of CPS Transformation]
If $\CPSprog{\Gamma}{D}{D'}$, then the following holds:
$\App{\main}{0} \Reds{D} v$ if and only if $\App{\App{\main}{0}}{(\Abs{x}{x})} \Reds{D'} v$.
\end{theorem}

%\memo{How to infer types and labels?}
