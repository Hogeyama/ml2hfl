\subsection{Selective CPS transformation}
\label{sec:CPS}
%\TODO{Add discussion about the increase of the order of programs}

This section formalizes selective CPS transformation for abstracted
programs.  As stated in Sect.~\ref{sec:intro}, the idea for selective CPS
transformation is to distinguish whether a continuation parameter should
be inserted to each expression or not based on whether it has a side-effect.  When a function application has
side-effects, we need not insert continuations in CPS transformation.
Here, $\FAIL$, non-deterministic branch, and non-termination are
considered as side-effects.
%For example, since an
%application of function $\Abs{x}{\Abs{y}{\Assert{x+y}}}$ to a value has
%no side-effects, it can be transformed to CPS by inserting only one
%continuation like $\Abs{x}{\Abs{y}{\Abs{k}{\App{k}{(x+y)}}}}$ instead of
%$\Abs{x}{\Abs{k}{\App{k}{(\Abs{y}{\Abs{k'}{\App{k'}{(x+y)}}})}}}$.

Note that a similar transformation has been proposed by
Nielsen~\cite{Nielsen2001}.  The transformation does not fit our purpose
of translating call-by-value programs into equivalent call-by-name
programs.  A non-terminating program may be transformed into a
terminating (call-by-name) program by their transformation.
%The reason is that programs obtained by their transformation do not
%yield the same results under a call-by-value semantics and a
%call-by-name semantics.  To be more precise, the transformation does not
%treat non-termination as a side-effect.

To decide whether we should insert a continuation or not, we
annotate each function type with a label $\ell \in \{\NC,\IC\}$, like
$\TFunL{\ell}{\tau_1}{\tau_2}$ .  A type $\TFunC{\tau_1}{\tau_2}$ means
that we should insert a continuation, and $\TFunN{\tau_1}{\tau_2}$ means
not.

%\begin{example}[Selective CPS Transformation]
%Consider the following program.
%\begin{alltt}
%let apply = \(\lambda\)x.\(\lambda\)f. f x
%let check = \(\lambda\)x.\(\lambda\)y. assert (x = y)
%let main = \(\lambda\)n. apply n (check n)
%\end{alltt}
%We can translated this program into the following program by na\"{\i}ve CPS transformation.
%\begin{alltt}
%let apply = \(\lambda\)x.\(\lambda\)k1. k1 (\(\lambda\)f.\(\lambda\)k2. f x k2)
%let check = \(\lambda\)x.\(\lambda\)k1. k1 (\(\lambda\)y.\(\lambda\)k2. assert (x = y); k2 ())
%let main = \(\lambda\)n.\(\lambda\)k. check n (\(\lambda\)f1. apply n (\(\lambda\)f2. f2 f1 k))
%\end{alltt}
%The order of this program is \emph{fifth}, i.e. the order of \texttt{apply}.
%%\mathtt{apply}\COL\TFun{\INT}{\TFun{(\TFun{(\TFun{(\TFun{\INT}{\TFun{(\TFun{\INT}{\UNIT})}{\UNIT}})}{\TFun{(\TFun{\INT}{\UNIT})}{\UNIT}})}{\UNIT})}{\UNIT}}
%On the other hand, considering the following annotated program,
%\begin{alltt}
%let apply = \(\lambda\sp{\NC}\)x.\(\lambda\sp{\IC}\)f. f x
%let check = \(\lambda\sp{\IC}\)x.\(\lambda\sp{\IC}\)y. assert (x = y)
%let main = \(\lambda\sp{\IC}\)n. apply n (check n)
%\end{alltt}
%we can translate the program into the following \emph{third} order CPS program.
%\begin{alltt}
%let apply = \(\lambda\)x.\(\lambda\)f.\(\lambda\)k. f x k
%let check = \(\lambda\)x.\(\lambda\)k1. = k1 (\(\lambda\)y.\(\lambda\)k. assert (x = y); k ())
%let main = \(\lambda\)n.\(\lambda\)k. check n (\(\lambda\)f. apply n f k)
%\end{alltt}
%\end{example}

%We used the model checker TRecS in our previous verifier.  Described in
%Section~\ref{model-check}, since TRecS is a model checker for
%higher-order recursion scheme, we need CPS transformation to apply TRecS
%to call-by-value programs.  A na\"{\i}ve CPS transformation, however,
%becomes programs complicate and higher-order.
%
%A selective CPS transformation is a CPS transformation that only
%transforms functions with side effects.

We first define the source language of selective CPS transformation.
The language is the same as the source language except: (i) the set
of terms is extended with non-deterministic branch $\Br{t_1}{t_2}$, and (ii)
each function type is attached to a label $\ell \in \{\NC,\IC\}$, like
$\TFunL{\ell}{\tau_1}{\tau_2}$.

%\begin{eqnarray*}
% t\text{ (terms)} &::=& \cdots \mid \AbsT{x}{\tau}{t} \mid \AbsTC{x}{\tau}{t} \\
% v\text{ (values)} &::=& \cdots \mid \AbsT{x}{\tau}{t} \mid \AbsTC{x}{\tau}{t} \\
% \tau\text{ (types)} &::=& \cdots \mid \TFunC{\tau_1}{\tau_2}
%\end{eqnarray*}

Below, we formalize the selective CPS as a type-based transformation.
Figure~\ref{fig:cps} shows the rules of the selective CPS
transformation.  The relation $\CPS{\Gamma}{t}{\tau}{\ell}{t'}$ means
that a term $t$ is translated to a term $t'$ by using a type $\tau$,
under the assumption that each free variable $x$ of $t$ has been
transformed using the type $\Gamma(x)$, $t$ has a side-effect if
$\ell=\IC$, and $t$ has no side-effect if $\ell=\NC$.
%Here, $\MAbs{x}{t}$ and
%$\MApp{t_1}{t_2}$ are, respectively, application and abstraction that
%will be reduced statically in the translation.

\begin{figure}[tp]
\begin{minipage}{\textwidth}
\infax[CPS-Const]
 {\CPS{\Gamma}{n}{\INT}{\NC}{n}}

\medskip

\infax[CPS-Var]
 {\CPS{\Gamma,x\COL\tau}{x}{\tau}{\NC}{x}}

\medskip

\infax[CPS-Op]
 {\CPS{\Gamma}{\Op{v_1,\dots,v_n}}{\INT}{\NC}{\Op{v_1,\dots,v_n}}}

\medskip

\infrule[CPS-AbsN]
 {\CPS{\Gamma, x\COL\tau_1}{t}{\tau_2}{\NC}{t'}}
 {\CPS{\Gamma}{\Abs{x}{t}}{\TFunN{\tau_1}{\tau_2}}{\NC}{\Abs{x}{t'}}}

\medskip

\infrule[CPS-AbsC]
 {\CPS{\Gamma, x\COL\tau_1}{t}{\tau_2}{\ell}{t'}}
 {\CPS{\Gamma}{\Abs{x}{t}}{\TFunL{C}{\tau_1}{\tau_2}}{\NC}
  {\Abs{x}{\Abs{k}{\SApp{\ell}{t'}{k}}}}}

\medskip

\infrule[CPS-AppN]
 {\CPS{\Gamma}{t_0}{\TFunN{\tau_1}{\tau}}{\NC}{t_0'} \andalso
  \CPS{\Gamma}{t_1}{\tau_1}{\NC}{t_1'}}
 {\CPS{\Gamma}{\App{t_0}{t_1}}{\tau}{\NC}
  {\App{t_0'}{t_1'}}}

\medskip

\infrule[CPS-AppC]
 {\CPS{\Gamma}{t_0}{\TFunL{\ell}{\tau_1}{\tau}}{\ell_0}{t_0'} \andalso
  \CPS{\Gamma}{t_1}{\tau_1}{\ell_1}{t_1'}}
 {\CPS{\Gamma}{\App{t_0}{t_1}}{\tau}{\IC}
  {\Abs{k}{\SApp{\ell_0}{t_0'}{\Abs{x_0}{\SApp{\ell_1}{t_1'}{\Abs{x_1}{\SApp{\ell}{\App{x_0}{x_1}}{k}}}}}}}}

%\medskip
%
%\infrule[CPS-AppN]
% {\CPS{\Gamma}{t_0}{\TFunN{\tau_1}{\TFunN{\cdots}{\TFunN{\tau_n}{\tau}}}}{\NC}{t_0'} \andalso
%  \CPS{\Gamma}{t_i}{\tau_i}{\NC}{t_i'} \quad \text{for each $i \in \set{1,\dots,n}$}}
% {\CPS{\Gamma}{\App{\App{\App{t_0}{t_1}}{\dots}}{t_n}}{\tau}{\NC}
%  {\App{\App{\App{t_0'}{t_1'}}{\ldots}}{t_n'}}}
%
%\medskip
%
%\infrule[CPS-AppC]
% {\CPS{\Gamma}{t_0}{\TFunL{l_1}{\tau_1}{\TFunL{l_{n-1}}{\cdots}{\TFunL{l_n}{\tau_n}{\tau}}}}{l_0}{t_0'} \andalso
%  \CPS{\Gamma}{t_i}{\tau_i}{l_i}{t_i'} \quad \text{for each $i \in \set{1,\dots,n}$}}
% {\CPS{\Gamma}{\App{\App{\App{t_0}{t_1}}{\dots}}{t_n}}{\tau}{\IC}
%  {\Abs{k}{\SApp{l_0}{t_0'}{\Abs{x_0}{\SApp{l_1}{t_1'}{\Abs{x_1}{\cdots\SApp{l_n}{t_n'}{\Abs{x_n}{\App{\App{\App{\App{x_0}{x_1}}{\ldots}}{x_n}}{k}}}\cdots}}}}}}}
%
\medskip

\infax[CPS-Fail]
 {\CPS{\Gamma}{\FAIL}{\tau}{\IC}{\Abs{k}{\FAIL}}}

\medskip

\infrule[CPS-IfN]
 {\CPS{\Gamma}{t_1}{\INT}{\NC}{t_1'} \andalso
  \CPS{\Gamma}{t_2}{\tau}{\NC}{t_2'} \andalso
  \CPS{\Gamma}{t_3}{\tau}{\NC}{t_3'}}
 {\CPS{\Gamma}{\If{t_1}{t_2}{t_3}}{\tau}{\NC}
  {\If{t_1'}{t_2'}{t_3'}}}

\medskip

\infrule[CPS-IfC]
 {\CPS{\Gamma}{t_1}{\INT}{\ell_1}{t_1'} \andalso
  \CPS{\Gamma}{t_2}{\tau}{\ell_2}{t_2'} \andalso
  \CPS{\Gamma}{t_3}{\tau}{\ell_3}{t_3'}}
 {\CPS{\Gamma}{\If{t_1}{t_2}{t_3}}{\tau}{\IC}
  {\Abs{k}{\SApp{\ell_1}{t_1}{\Abs{m}{\If{m}{\SApp{\ell_2}{t_2'}{k}}{\SApp{\ell_3}{t_3'}{k}}}}}}}

\medskip

\infrule[CPS-Br]
 {\CPS{\Gamma}{t_1}{\tau}{\ell_1}{t_1'} \andalso
  \CPS{\Gamma}{t_2}{\tau}{\ell_2}{t_2'}}
 {\CPS{\Gamma}{\Br{t_1}{t_2}}{\tau}{\IC}
  {\Abs{k}{\If{\Br{0}{1}}{\SApp{\ell_1}{t_2'}{k}}{\SApp{\ell_2}{t_3'}{k}}}}}

\medskip

\infrule[CPS-Prog]
 {v_i \text{ is of the form } \Abs{x_1}{\Abs{x_2}{\dots\Abs{x_j}{t_i}}} \andalso
  t_i \text{ is not of the form } \Abs{x}{t_i'} \\
  \Gamma(f_i) \text{ is of the form } \TFunL{\ell_1}{\tau_{i1}}{\TFunL{\ell_2}{\tau_{i2}}{\TFunL{\ell_{k_i-1}}{\cdots}{\TFunC{\tau_{ik_i}}{\tau}}}} \\
  \CPS{\Gamma}{v_i}{\Gamma(f_i)}{\NC}{v_i'} \quad \text{for each $i \in \set{1,\dots,n}$}}
 {\CPSprog{\Gamma}{\{f_1=v_1,\dots,f_n=v_n\}}{\{f_1=v_1',\dots,f_n=v_n'\}}}

\begin{eqnarray*}
 \SApp{\NC}{t}{k} &=& \App{k}{t} \\
 \SApp{\IC}{t}{k} &=& \App{t}{k}
\end{eqnarray*}

\end{minipage}
\caption{Selective CPS transformatation}
\label{fig:cps}
\end{figure}

%\begin{figure}[htbp]
%\begin{minipage}{\textwidth}
%\infax[CPS-Const]
% {\CPS{\Gamma}{n}{\INT}{\NC}{\Abs{\kappa}{\App{\kappa}{n}}}}
%
%\medskip
%
%\infax[CPS-Var]
% {\CPS{\Gamma,x\COL\tau}{x}{\tau}{\NC}{\Abs{\kappa}{\App{\kappa}{x}}}}
%
%\medskip
%
%\infax[CPS-Op]
% {\CPS{\Gamma}{\Op{v_1,\dots,v_n}}{\INT}{\NC}{\Abs{\kappa}{\App{\kappa}{(\Op{v_1,\dots,v_n})}}}}
%
%\medskip
%
%\infrule[CPS-AbsN]
% {\CPS{\Gamma, x\COL\tau_1}{t}{\tau_2}{\NC}{t'}}
% {\CPS{\Gamma}{\Abs{x}{t}}{\TFunN{\tau_1}{\tau_2}}{\NC}
%  {\Abs{\kappa}{\Abs{x}{\App{t'}{(\Abs{m}{\App{\kappa}{m}})}}}}}
%
%\medskip
%
%\infrule[CPS-AbsC]
% {\CPS{\Gamma, x\COL\tau_1}{t}{\tau_2}{\IC}{t'}}
% {\CPS{\Gamma}{\Abs{x}{t}}{\TFunC{\tau_1}{\tau_2}}{\NC}
%  {\Abs{\kappa}{\App{\kappa}{(\Abs{x}{\Abs{k}{\App{t'}{(\Abs{m}{\App{k}{m}})}}})}}}}
%
%\medskip
%
%\infrule[CPS-AppN]
% {\text{$t_0$ is not of the form $\App{\App{\App{f}{t_{00}}}{\ldots}}{t_{0k}}$} \\
%  \CPS{\Gamma}{t_0}{\TFunN{\tau_1}{\TFunN{\cdots}{\TFunN{\tau_n}{\tau}}}}{\NC}{t_0'} \andalso
%  \CPS{\Gamma}{t_i}{\tau_i}{\NC}{t_i'} \quad \text{for each $i \in \set{1,\dots,n}$}}
% {\CPS{\Gamma}{\App{\App{\App{t_0}{t_1}}{\dots}}{t_n}}{\tau}{\NC}
%  {\Abs{\kappa}{\App{\kappa}{(\App{t_0'}{(\Abs{x_0}{\App{t_1'}{(\Abs{x_1}{\cdots(\Abs{x_n}{\App{\App{\App{x_0}{x_1}}{\ldots}}{x_n}})\cdots})}})})}}}}
%
%\medskip
%
%\infrule[CPS-AppC]
% {\CPS{\Gamma}{t_0}{\TFunL{l_1}{\tau_1}{\TFunL{l_{n-1}}{\cdots}{\TFunC{\tau_n}{\tau}}}}{l}{t_0'} \andalso
%  \CPS{\Gamma}{t_i}{\tau_i}{l_i'}{t_i'} \quad \text{for each $i \in \set{1,\dots,n}$}}
% {\CPS{\Gamma}{\App{\App{\App{t_0}{t_1}}{\dots}}{t_n}}{\tau}{\IC}
%  {\Abs{\kappa}{\App{t_0'}{(\Abs{x_0}{\App{t_1'}{(\Abs{x_1}{\cdots(\Abs{x_n}{\App{\App{\App{\App{x_0}{x_1}}{\ldots}}{x_n}}{(\Abs{r}{\App{\kappa}{r}})}})\cdots})}})}}}}
%
%\medskip
%
%\infax[CPS-Fail]
% {\CPS{\Gamma}{\FAIL}{\tau}{\IC}{\Abs{\kappa}{\FAIL}}}
%
%\medskip
%
%\infrule[CPS-If]
% {\CPS{\Gamma}{t_1}{\INT}{l}{t_1'} \andalso
%  \CPS{\Gamma}{t_2}{\tau}{l}{t_2'} \andalso
%  \CPS{\Gamma}{t_3}{\tau}{l}{t_3'}}
% {\CPS{\Gamma}{\If{t_1}{t_2}{t_3}}{\tau}{l}
%  {\Abs{\kappa}{\App{t_1}{(\Abs{m}{\If{m}{\App{t_2'}{\kappa}}{\App{t_3'}{\kappa}}})}}}}
%
%\medskip
%
%\infrule[CPS-Br]
% {\CPS{\Gamma}{t_1}{\tau}{l_1}{t_1'} \andalso
%  \CPS{\Gamma}{t_2}{\tau}{l_2}{t_2'}}
% {\CPS{\Gamma}{\Br{t_1}{t_2}}{\tau}{\IC}
%  {\Abs{\kappa}{\If{\Br{0}{1}}{\App{t_2'}{\kappa}}{\App{t_3'}{\kappa}}}}}
%
%\medskip
%
%\infrule[CPS-Prog]
% {\CPS{\Gamma}{v_i}{\Gamma(f_i)}{\NC}{v_i'} \quad \text{for each $i \in \set{1,\dots,n}$}}
% {\CPSprog{\Gamma}{\{f_1=v_1,\dots,f_n=v_n\}}{\{f_1=\App{v_1}{(\Abs{m}{m})},\dots,f_n=\App{v_n}{(\Abs{m}{m})}\}}}
%
%%\begin{eqnarray*}
%% \CPSty{b} &=& b \\
%% \CPSty{\TFunC{\tau_1}{\tau_2}} &=& \TFun{\CPSty{\tau_1}}{\TFun{(\TFun{\CPSty{\tau_2}}{\UNIT})}{\UNIT}} \\
%% \CPSty{\TFun{\tau_1}{\tau_2}} &=& \TFun{\CPSty{\tau_1}}{\CPSty{\tau_2}}
%%\end{eqnarray*}
%\end{minipage}
%\caption{Selective CPS transformatation}
%\label{fig:cps}
%\end{figure}

The rules are designed in such a way that transformed term $t'$ has type
$\CPSty{\tau}$ if $\CPS{\Gamma}{t}{\tau}{N}{t'}$ holds, and the transformed
term $t'$ has type $\TFun{(\TFun{\CPSty{\tau}}{\AT})}{\AT}$ if
$\CPS{\Gamma}{t}{\tau}{C}{t'}$ holds, where $\AT$ is the answer type and
$\CPSty{\tau}$ is defined by:
\begin{eqnarray*}
 \CPSty{\INT} &=& \INT \\
 \CPSty{\TFunN{\tau_1}{\tau_2}} &=& \TFun{\CPSty{\tau_1}}{\CPSty{\tau_2}} \\
 \CPSty{\TFunC{\tau_1}{\tau_2}} &=& \TFun{\CPSty{\tau_1}}{\TFun{(\TFun{\CPSty{\tau_2}}{\AT})}{\AT}}
\end{eqnarray*}
This shows the intuition that a term of a type $\TFunC{\tau_1}{\tau_2}$
should be inserted a continuation, and another term remains in direct
style.

In the rule \rn{CPS-AbsC}, a term $\Abs{x}{t}$ is transformed in a
standard way, i.e. a continuation parameter $k$ is inserted and $t'$,
the CPS version of $t$, is applied to $k$.  On the other hand, in the
rule \rn{CPS-AbsN}, no continuation parameter is inserted and direct
style is preserved.  The rules for applications are similar. In the rule
\rn{CPS-AppC}, a continuation is inserted, but not in the rule
\rn{CPS-AppN}.  In the rule \rn{CPS-Br}, a term $\Br{t_1}{t_2}$ should
be transformed with $\IC$ and a continuation is needed because we treat
non-deterministic branch as a side-effect.
In the rule \rn{CPS-Prog}, since an
application of a top-level function may cause a side-effect,
non-termination, the function type for the last argument is annotated
with $\IC$.  Although this is a na\"{\i}ve way to transform
non-terminating terms, we can avoid redundant insertion of continuations
by some termination analysis.

{
\def\check{\mathtt{check}}
\def\apply{\mathtt{apply}}
\def\assert{\mathtt{assert}}
\def\assertcps{\mathtt{assert}_\mathtt{CPS}}

Figure~\ref{fig:cps-example} shows examples of selective CPS
transformation.  The examples are the transformations of
$\Abs{x}{\Abs{y}{\assert(x = y)}}$ with type
$\TFunN{\INT}{\TFunC{\INT}{\INT}}$ for (a) and
$\TFunN{\INT}{\TFunN{\INT}{\INT}}$ for (b).
The transformation of $\Abs{y}{\assert(x = y)}$ in (b) is the same in (a).
In (a), there is no need to insert a continuation parameter to the back of $x$.
On the other hand, in (b), a continuation parameter is inserted.

\begin{figure}[tp]
\begin{minipage}{\textwidth}
\infer{
\CPS{\Gamma}
     {\Abs{x}{\Abs{y}{\assert(x = y)}}}
     {\TFunN{\INT}{\TFunC{\INT}{\INT}}}{\NC}
     {\Abs{x}{\Abs{y}{\Abs{k}{\App{\App{\assertcps}{(x=y)}}{k}}}}}
}{
\infer{
 \CPS{\Gamma_x}
     {\Abs{y}{\App{\assert}{(x = y)}}}
     {\TFunC{\INT}{\INT}}{\NC}
     {\Abs{y}{\Abs{k}{\App{\App{\assertcps}{(x=y)}}{k}}}}
}{
\infer{
 \CPS{\Gamma_{xy}}
     {\App{\assert}{(x = y)}}
     {\INT}{\IC}
     {\Abs{k}{\App{\App{\assertcps}{(x=y)}}{k}}}
}{
 \CPS{\Gamma_{xy}}{\assert}{\TFunC{\INT}{\INT}}{\NC}{\assertcps}
  &
 \infer{\CPS{\Gamma_{xy}}{x=y}{\INT}{\NC}{x=y}}{\vdots}
}}}
(a)

\infer{
 \CPS{\Gamma}
     {\Abs{x}{\Abs{y}{\assert(x = y)}}}
     {\TFunC{\INT}{\TFunC{\INT}{\INT}}}{\NC}
     {\Abs{x}{\Abs{k'}{\App{k'}{(\Abs{y}{\Abs{k}{\App{\App{\assertcps}{(x=y)}}{k}}})}}}}
}{
\infer{
 \CPS{\Gamma_x}
     {\Abs{y}{\App{\assert}{(x = y)}}}
     {\TFunC{\INT}{\INT}}{\NC}
     {\Abs{y}{\Abs{k}{\App{\App{\assertcps}{(x=y)}}{k}}}}
}{\vdots}}
(b)
\end{minipage}
\caption{Transformation of $\Abs{x}{\Abs{y}{\assert(x =
y)}}$. ($\Gamma_x=\Gamma,x\COL\INT$ and
$\Gamma_{xy}=\Gamma_x,y\COL\INT$)}
\label{fig:cps-example}
\end{figure}
}

In the following, we discuss the properties of selective CPS transformation.
The theorem below shows that we can transform arbitrary simply-typed programs into CPS.
\begin{theorem}
Suppose $D$ is typable in $\Gamma$. There exists $D'$ such that $\CPSprog{\Gamma}{D}{D'}$.
\end{theorem}
The following theorem states the correctness of the selective CPS
transformation, in the sense that the transformed program is reduced to
the same value as the original program.
\begin{theorem}[Correctness of CPS Transformation]
If $\CPSprog{\Gamma}{D}{D'}$, then the following holds:
$\App{\main}{n} \Reds{D} \FAIL$ if and only if $\App{\App{\main}{n}}{(\Abs{x}{x})} \Reds{D'} \FAIL$.
\end{theorem}

%\memo{How to infer types and labels?}
