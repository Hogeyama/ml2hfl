
\section{Optimizations}
\label{sec:opt}

This section introduces optimizations for each phase of predicate
abstraction and CPS transformation in Fig.~\ref{fig:cegar}.

\subsection{Selective Predicate Abstraction}

We introduce an optimization technique for predicate abstraction, called
selective predicate abstraction.  Selective predicate abstraction
improves the precision of abstraction.

The idea of selective predicate abstraction is to distinguish functions
that are abstracted from those that are not abstracted.  For
example, the program in Fig.~\ref{fig:abst-example} can be verified by
abstracting only \texttt{sum} and \texttt{main} as stated in
Sect.~\ref{sec:intro}.

We formalize selective predicate abstraction as an extension of the
previous predicate abstraction.  In the previous framework, predicate
abstraction is defined as the relation
$\AbstPLDI{\Gamma}{t}{\sigma}{t'}$ that reads $t$ is abstracted to $t'$
by using the abstraction type\footnote{Abstraction types are types to
express which predicate should be used for each terms.  We do not show
the definition of abstraction types.  See our previous
paper~\cite{KobayashiPLDI2011} for details.}  $\sigma$ under the
assumption that each free variable x of $t$ has been abstracted using
the abstraction type $\Gamma(x)$.  We extend predicate abstract relation
by adding the set of inline functions $E$ like
$\Abst{\Gamma}{E}{t}{\sigma}{t'}$.  Here, functions in $E$ do not
abstracted and are extracted in the process of abstraction.  For
example, the abstraction of the program above is represented as the
relation
$\Abst{\mathtt{sum}\COL\sigma_\mathtt{sum},\mathtt{main}\COL\sigma_\mathtt{main}}{\mathtt{add}=\Abs{x}{\Abs{y}{x+y}}}{t}{\sigma}{t'}$.

%\begin{alltt}
%let pred x = x - 1
%let f x = assert (pred x > 0)
%let main x = if x > 1 then f x else ()
%\end{alltt}
%let rec succ n = n + 1
%    and check1 f = assert (f 1 = 2); check1 f
%    and check2 f = assert (f 2 = 3); check2 f
%    and main b = if b then check1 succ else check2 succ
%In our previous framework, we need the following abstraction types to verify the program.
%\[
% \mathtt{pred}\COL\TFun{a}{}, \mathtt{f}\COL\TFun{}{}, \mathtt{main}\COL\TFun{}{}
%\]
%This program can be verified by using the following abstraction types,
%which denotes how predicates we should use to abstract each terms:
%\begin{eqnarray*}
%\mathtt{succ} &:& \TFun{\INT[\Abs{x}{x=1}, \Abs{x}{x=2}]}{\INT[\Abs{x}{x=2}, \Abs{x}{x=3}]} \\
%\mathtt{check1} &:& \TFun{(\TFun{\INT[\Abs{x}{x=1}]}{\INT[\Abs{x}{x=2}]})}{\UNIT} \\
%\mathtt{check2} &:& \TFun{(\TFun{\INT[\Abs{x}{x=2}]}{\INT[\Abs{x}{x=3}]})}{\UNIT} \enspace .
%\end{eqnarray*}
%The type of \texttt{succ} means that the return value is abstracted by predicates
%$\Abs{x}{x=2}$ and $\Abs{x}{x=3}$ assuming that the argument is
%abstracted by predicates $\Abs{x}{x=1}$ and $\Abs{x}{x=2}$.  In fact, it
%is sufficient for verification to use abstraction type
%$\TFun{\INT[\Abs{x}{x=1}]}{\INT[\Abs{x}{x=2}]}$ for \texttt{succ} in
%\texttt{check1 succ}, and
%$\TFun{\INT[\Abs{x}{x=2}]}{\INT[\Abs{x}{x=3}]}$ for \texttt{succ} in
%\texttt{check2 succ}.  Moreover, we can infer these types of
%\texttt{succ} from the callee sides (i.e., just using the argument type
%of check1 and check2.)

%We formalize this abstraction, called selective predicate abstraction,
%as an extension of the previous predicate abstraction.
Figure~\ref{fig:abstraction} shows the key rules of the selective
predicate abstraction.  Other rules are same as the previous predicate
abstraction relation~\cite{KobayashiPLDI2011} except that the extracting
function definition $E$ is added.  The relation
$\Abst{\Gamma}{E}{t}{\tau}{t'}$ reads $t$ is abstracted to $t'$ by using
the abstraction type $\tau$ under the assumption that each free variable
x of $t$ has been abstracted using the abstraction type $\Gamma(x)$ or
the definition of $x$ is the abstraction of $E(x)$.
%$E=\set{f_{i_1}=v_{i_1},\dots,f_{i_k}=v_{i_k}}$ is a subset of a
%program.
%A function definition is in E intuitively means the function
%is expanded in the abstraction.

If $E$ is the empty set, the abstract
relation is same as the previous predicate abstraction.

%\begin{equation*}
%V_{D_1,D_2} = \{f \mid (f,t) \in (D_1 \cup D_2)\}
%\end{equation*}
%\begin{equation*}
%E_{D_1,D_2} = \{(f,g) \mid (f,t) \in D_2, g \in \FV{t}\}
%\end{equation*}
%$\ExpNRec{D_2}{-}$ terminates if the graph $(V_{D_1,D_2},E_{D_1,D_2})$ is acyclic.

%\begin{eqnarray*}
% \ExpNRec{D}{c} &=& c \\
% \ExpNRec{D}{x} &=& \left\{
%                     \begin{array}{ll}
%                      x              & \quad \text{$(x,t) \notin D$ for any $t$}  \\
%                      \ExpNRec{D}{t} & \quad \text{$(x,t) \in D$}
%                     \end{array}
%                    \right. \\
% \ExpNRec{D}{\App{t_1}{t_2}} &=& \App{\ExpNRec{D}{t_1}}{\ExpNRec{D}{t_2}} \\
% \ExpNRec{D}{\Op{v_1,\dots,v_n}} &=& \Op{\ExpNRec{D}{v_1}, \dots, \ExpNRec{D}{v_n}} \\
%% \ExpNRec{D}{\If{t_1}{t_2}{t_3}} &=& \If{\ExpNRec{D}{t_1}}{\ExpNRec{D}{t_2}}{\ExpNRec{D}{t_3}}
%\end{eqnarray*}

%\begin{figure}[t]
%\begin{minipage}{\textwidth}
%\infax[Exp-Int]
% {\Exp{D}{n}{n}}
%
%\medskip
%
%\infrule[Exp-Var1]
% {x = t \notin D \text{ for any } t}
% {\Exp{D}{x}{x}}
%
%\medskip
%
%\infrule[Exp-Var2]
% {\Exp{D}{t}{t'}}
% {\Exp{D,x=t}{x}{t'}}
%
%\medskip
%
%\infrule[Exp-Op]
% {\Exp{D}{v_i}{v_i'} \text{ for each } i}
% {\Exp{D}{\Op{v_1,\dots,v_n}}{\Op{v_1,\dots,v_n}}}
%
%\medskip
%
%\infrule[Exp-Abs]
% {\Exp{D}{t}{t'}}
% {\Exp{D}{\Abs{x}{t}}{\Abs{x}{t'}}}
%
%\medskip
%
%\infrule[Exp-App]
% {\Exp{D}{t_1}{t_1'} \andalso
%  \Exp{D}{t_2 }{t_2'}}
% {\Exp{D}{\App{t_1}{t_2}}{\App{t_1'}{t_2'}}}
%
%\medskip
%
%\infax[Exp-Fail]
% {\Exp{D}{\FAIL}{\FAIL}}
%
%\medskip
%
%\infrule[Exp-If]
% {\Exp{D}{t_1}{t_1'} \andalso
%  \Exp{D}{t_2}{t_2'} \andalso
%  \Exp{D}{t_3}{t_3'}}
% {\Exp{D}{\If{t_1}{t_2}{t_3}}{\If{t_1'}{t_2'}{t_3'}}}
%\end{minipage}
%\caption{Inline Expansion}
%\label{fig:inlining}
%\end{figure}

\begin{figure}[t]
\begin{minipage}{\textwidth}
\infrule[A-App]
 {x\notin\Dom{E} \andalso \Gamma(x)=(y_1\COL\sigma_1 \to \cdots \to y_n\COL\sigma_n \to\sigma) \\
  \Abst{\Gamma,y_1:\sigma_1,\dots,y_{i-1}:\sigma_{i-1}}{E}{v_i}{[v_1/y_1,\ldots,v_{i-1}/y_{i-1}]\sigma_i}{e_i} \\
  \text{for each $i\in\set{1,\ldots,n}$}}
 {\Abst{\Gamma}{E}{\App{x}{\seq{v}}}{[\seq{v}/\seq{y}]\sigma}{
  \Let{y_1}{e_1}{\cdots\Let{y_n}{e_n}{\App{x}{\seq{y}}}}}}

\medskip

\infrule[A-AppExp]
 {E(x) = e \andalso
  \Abst{\Gamma}{E}{e}{(y_1\COL\sigma_1 \to \cdots \to y_n\COL\sigma_n \to\sigma)}{e'} \\
  \Abst{\Gamma,y_1:\sigma_1,\dots,y_{i-1}:\sigma_{i-1}}{E}{v_i}{[v_1/y_1,\ldots,v_{i-1}/y_{i-1}]\sigma_i}{e_i} \\
  \text{for each $i\in\set{1,\ldots,n}$}}
 {\Abst{\Gamma}{E}{\App{x}{\seq{v}}}{[\seq{v}/\seq{y}]\sigma}{
  \Let{x'}{e'}{\Let{y_1}{e_1}{\cdots\Let{y_n}{e_n}{\App{x'}{\seq{y}}}}}}}

\medskip

\infrule[A-Let]
  {\Abst{\Gamma}{E,x=e_1}{e_2}{\sigma}{e_2'}}
  {\Abst{\Gamma}{E}{\Let{x}{e_1}{e_2}}{\sigma}{e_2'}}

%\medskip
%
%\infrule[A-Prog]
%  {\Abst{\Gamma}{E}{v_i}{\Gamma(f_i)}{v_i'} \andalso
%   \text{for each $i \in \set{1,\dots,n}$} \andalso \Dom{}}
%  {\AbstProg{\Gamma}{E}{\set{f_1 = v_1, \dots, f_n = v_n}}{\set{f_1 = v_1', \dots, f_n = v_n'}}}
\end{minipage}
\caption{Selective Predicate Abstraction}
\label{fig:abstraction}
\end{figure}

For some $D$ and $E$, there is $D'$ such that
$\AbstProg{\Gamma}{E}{D}{D'}$ when there is no cyclic definitions in $E$
like $\set{f = \Abs{x}{\App{f}{x}}}$.  Therefore, recursive functions
should be basically in $\Dom{\Gamma}$, and non-recursive functions
should be in $\Dom{E}$.  Even if there are some recursive functions in
$E$, there is $D'$ such that $\AbstProg{\Gamma}{E}{D}{D'}$ in some cases.
For example, the following program can be abstracted when $E = \set{\texttt{odd} = v_\texttt{odd}}$.
\begin{alltt}
let rec even x = if x = 0 then true else odd (x-1)
    and odd x = if x = 1 then true else even (x-1) in
let main n = even n
\end{alltt}

Selective predicate abstraction is similar to the method to reduce type
declarations by local type inference~\cite{} in the sense that the types
of non-recursive functions are inferred from the types of recursive functions.

We discuss properties of the selective predicate abstraction. \cc{We show that
selective predicate abstraction is sound and, in a sense, enough precise.}

The theorem below states that selective predicate abstraction is sound
in the sense that if the original program fails then so does its
abstracted program.

\begin{theorem}[soundness]
 If $\AbstProg{\emptyset}{E}{D_1}{D_2}$, and
 $\App{\main}{0} \Reds{D_1} \FAIL$, then
 $\App{\main}{0} \Reds{D_2} \FAIL$.
\end{theorem}

%\begin{theorem}
% If $\Abst{\Gamma}{D}{t}{\tau}{t_1}$,
% $\Abst{\Gamma}{D'}{t}{\tau}{t_2}$,
% $D \subseteq D'$,
% $t_1 \reds \FAIL$ then
% $t_2 \reds \FAIL$.
%\end{theorem}

The following theorem states that selective predicate abstraction is
more precise compared to our previous predicate abstraction.  Here,
$\AbstPLDI{\Gamma}{D}{\tau}{D_1}$ is the predicate abstract relation in
our previous paper~\cite{KobayashiPLDI2011}.

\begin{theorem}
 If $\AbstPLDI{}{D}{\tau}{D_1}$,
 $\Abst{\emptyset}{E}{D}{\tau}{D_2}$, and
 $\App{\main}{0} \Reds{D_2} \FAIL$, then
 $\App{\main}{0} \Reds{D_1} \FAIL$.
\end{theorem}

%As a consequence of the theorem, we can show that selective predicate
%abstraction with higher-order model checking has at least the same
%verification power of the

%\begin{figure}[t]
%\begin{minipage}{\textwidth}
%
%\infrule[Aff-Const]
% {}
% {\AffineT{S}{f}{n}}
%
%\medskip
%
%\infrule[Aff-Var1]
% {f \in S}
% {\AffineT{S}{f}{f}}
%
%\medskip
%
%\infrule[Aff-Var2]
% {f \neq x}
% {\AffineT{S}{f}{x}}
%
%\medskip
%
%\infax[Aff-Op]
% {\AffineT{S}{f}{\Op{v_1,\dots,v_n}}}
%
%\medskip
%
%\infrule[Aff-Abs]
% {\AffineT{S}{f}{t}}
% {\AffineT{S}{f}{\Abs{x}{t}}}
%
%\medskip
%
%\infrule[Aff-App]
% {\AffineT{S_1}{f}{t_1} \andalso
%  \AffineT{S_2}{f}{t_2} \andalso
%  S = S_1 \uplus S_2}
% {\AffineT{S}{f}{\App{t_1}{t_2}}}
%
%\medskip
%
%\infrule[Aff-Fail]
% {}
% {\AffineT{S}{f}{\FAIL}}
%
%\medskip
%
%\infrule[Aff-If]
% {\AffineT{S_1}{f}{t_1} \andalso
%  \AffineT{S_2}{f}{t_2} \andalso
%  \AffineT{S_2}{f}{t_3} \andalso
%  S = S_1 \uplus S_2}
% {\AffineT{S}{f}{\If{t_1}{t_2}{t_3}}}
%
%\medskip
%
%\infrule[Aff-Prog]
% {\AffineT{S_i}{f}{t_i} \texttt{ for each $i$} \andalso
%  \{f\} = \biguplus S_i}
% {\Affine{f}{\{f_1=t_1,\dots,f_n=t_n\}}}
%
%\end{minipage}
%\caption{Definitions of $\Affine{-}{-}$ \memo{Can we define $\Affine{-}{-}$ only in writing?}}
%\label{fig:affine}
%\end{figure}



%\begin{theorem}
% Suppose Let $t$ be a term in program $D \supseteq D'$, there exists $t'$ such that $...$, if
% $\Affine{f_i}{D}$ holds or $t_i$ is closed, for each definition $f_i = t_i$ in $D'$:
%\end{theorem}
%Here, the definition of $\Affine{-}{-}$ is in
%Fig.~\ref{fig:affine}. $\Affine{f_i}{D}$ denotes $f_i$ is occurred at
%most once except that it counts as ones if $f_i$ occurred at most once
%each in the then-part and the else-part of an if-expression.


