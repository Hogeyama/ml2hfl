\section{Related Work}
\label{sec:related}

\subsection{Container Abstraction}
Dillig et al.~\cite{Dillig2011} have proposed an automatic technique for
static reasoning about containers.  The proposed framework is based on
an abstract interpretation for containers.  Their framework is similar
to our framework in the sense that they model containers as mappings
from location to values.  While they consider the client-side use of the
specific data structures (i.e. containers), we consider a more general
class of data structures include user-defined data structures.


\subsection{Verification Frameworks for Functional Programs}
There are several
frameworks~\cite{Kawaguchi2009,Chin2003,Unno2010,Ong2011} that aimed at
verification of functional programs with data structures.

Ong et al.~have proposed the verification framework for recursion scheme with
recursive data structures, called Pattern Matching Recursion Scheme.  As stated in
Sect.~\ref{}, their framework requires control flow analysis. Moreover,
the framework cannot deal with some regular properties. For example, the
framework cannot verify that a list obtained by applying the following
``id'' function to an even length list is also even length.
\begin{alltt}
let rec id x = match x with nil -> nil | cons x xs -> cons x (id xs)
\end{alltt}

Unno et al.~have proposed the verification framework for higher-order
tree processing functional programs. Their framework distinguish that
input tree types and output tree types.  In order to use output trees of
some function as input trees to some function, programmers have to
insert coercion functions with annotations of the properties of input
trees and the properties of output trees.
%\cc{This is the heavy burden to programmers}

Kawaguchi et al.'s liquid type inferecne~\cite{Kawaguchi2009} are
semi-automated verification framework based on refinement types.  Their
framework requires the shape of predicates, called logical qualifiers,
to users.  The limitation of our framework is that it cannot deal with
\cc{recursive dependency} on recursive data structures such that
orderedness.  Their framework can deal with recursive dependent type
such that $\App{\INT}{\LIST_\leq} = \mu t.\NIL +
\Cons{x_1\COL\INT}{x_2\COL\App{\{\nu\COL\INT \mid \nu \leq
x_1\}}{\LIST}}$, i.e., ordered lists of integers.  The framework,
however, cannot deal with the properties of list elements related to its
indices like that the $i$-th element of a list is greater than $i$.

Chin et al.'s sized type inference~\cite{Chin2003}.  Their framework
infers invariant of recursive functions by fix-point computation.  The
framework cannot handle higher-order functions.

\subsection{}
[Comparison with others (Soonho Kong et al. APLAS10, etc.)]
