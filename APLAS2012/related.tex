\section{Related Work}
\label{sec:related}

There are several
methods~\cite{Ong2011,Kobayashi2010,Unno2010,Rondon2008,Kawaguchi2009,Chin2003}
that are aimed at verification of functional programs with data
structures.

Ong and Ramsay~\cite{Ong2011} have proposed a verification method for
recursion schemes with recursive data structures, called Pattern Matching
Recursion Schemes (PMRSs).  The method cannot express regular properties
(such as ``a and b occur alternately'') and numerical properties (such
as ``$x+y \leq z$'' where $x,y,z$ are the length of lists).
%regular properties. For example, the method cannot
%verify that a list obtained by applying the following ``id'' function to
%an even length list is also even length.
%\begin{alltt}
%let rec id x = match x with nil -> nil | cons x xs -> cons x (id xs)
%\end{alltt}

Unno et al.~\cite{Unno2010} have also proposed a verification method for 
higher-order tree processing functional programs, which is based on a 
verification method for higher-order multi-tree 
transducers~\cite{Kobayashi2010}. Their method requires certain
invariant annotations to recursive data structures.
%\cc{This is the heavy burden to programmers}

Rondon et al.'s liquid type inference~\cite{Rondon2008,Kawaguchi2009} is a
semi-automated verification method based on refinement types.  Their method requires
users to provide templates of predicates, called logical qualifiers.  The
expressive power of their method and ours is incomparable.  They can
deal with ``recursive dependent types'', such as $\App{\INT}{\LIST_\leq}
= \mu t.\, \NIL$ $\mathop{+}
\Cons{x_1\COL\INT}{x_2\COL\App{\{\nu\COL\INT \mid x_1 \leq \nu\}}{t}}$,
which represents ordered lists of integers, while our method cannot. On
the other hand, our method can deal with the properties of list elements
related to their indices like ``the $i$-th element of a list is greater
than $i$,'' while they cannot.
%The limitation of our method is that it cannot
%deal with recursive dependency on recursive data structures such as
%orderedness.  Their method can deal with recursive dependent type
%such that $\App{\INT}{\LIST_\leq} = \mu t.\NIL +
%\Cons{x_1\COL\INT}{x_2\COL\App{\{\nu\COL\INT \mid \nu \leq x_1\}}{t}}$,
%i.e., ordered lists of integers.  The method, however, cannot deal
%with the properties of list elements related to its indices like that
%the $i$-th element of a list is greater than $i$.

Dillig et al.~\cite{Dillig2011} have proposed an automatic technique for 
statically reasoning about containers.  The proposed method is based on 
an abstract interpretation for containers.  Their method is similar to 
our method in the sense that they model containers as mappings from 
locations to values.  They consider only a client-side use of specific 
data structures (i.e. containers) such as primitive data structures and 
those defined in a standard library.  In contrast, our method can deal 
with user-defined data structures.  Moreover, as discussed in 
Sect.~\ref{sec:extension}, our method is strictly more expressive than 
their method.

Chin et al.~\cite{Chin2003} have proposed sized type inference.  Their
method infers invariant of recursive functions by fix-point computation.
By abstracting lists as multisets, their method can deal with the
inclusion relation and the membership relation on lists.  For example, their method
can verify that \texttt{exists x xs} returns true if and only if
\texttt{xs} has \texttt{x} as an element.  The method, however, cannot
properly handle higher-order functions.

Suter et al.~have proposed a verification method for first-order
functional programs that manipulate recursive data
structures~\cite{Suter2011}.  They use a decision
procedure~\cite{Suter2010} that is complete for recursive functions that
are sufficiently surjective catamoprhisms.  For example, their method
can verify that an insertion function preserves invariants of binary
search trees, while our method cannot.

Selective predicate abstraction has some similarity to local type
inference~\cite{Pierce2000} for reducing type declarations, in the sense
that the types of non-recursive functions are inferred from the types of
recursive functions.
