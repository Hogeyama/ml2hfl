<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//FR"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>
<TITLE>Caml Examples</TITLE>
</HEAD>

<BODY BGCOLOR="#FFFFFF">

<P>File created 2 February 2001.

<H1 ALIGN=CENTER><IMG SRC="../../gifs/JoeCaml.gif" ALT="">Simple and basic programs</H1>

<H2 ALIGN=LEFT>How to compile the programs</H2>

<P>Calling the Caml compiler:

<UL>
<LI>to compile the file <CODE>hello.ml</CODE> to executable
    program <CODE>a.out</CODE>, simply type
   <BR><CODE>ocamlc hello.ml</CODE>
<LI>to compile the file <CODE>hello.ml</CODE> to executable
    program <CODE>hello</CODE> type
    <BR><CODE>ocamlc -o hello hello.ml</CODE>
</UL>

<H2 ALIGN=LEFT>How to run the programs</H2>

<P>To run the compiled programs, use them as ordinary commands.

<P>For instance, to try the Caml programs <CODE>fib</CODE>, <CODE>wc</CODE>,
or <CODE>sieve</CODE>, type in:

<PRE>
        fib 10              # or some other number
        wc fib.ml           # or some other files
        sieve 1000          # or some other number
</PRE>


<H2 ALIGN=LEFT>How to try and test the programs with the interactive system</H2>

<P>To try the programs interactively: call the Caml interactive system and load
the programs using the <CODE>#load</CODE> directive.

<PRE>
        ocaml               # or better, ledit ocaml, if ledit is installed.
</PRE>

<P>Then type in (don't forget to type the initial <CODE>#</CODE> sign, that
indicates a directive)
<PRE>
        #use "fib.ml";;
</PRE>

<P>In sub directories that contain complex examples, a Caml source file
named <CODE>loadall.ml</CODE> is provided. In this case just type:
<PRE>
        #use "loadall.ml";;
</PRE>

<H2 ALIGN=LEFT>Automatic recompilation</H2>

<P>In sub directories that contain complex examples, a <CODE>Makefile</CODE> is
provided to automatically compile the set of Caml source files needed to
compile and link the program.

<P>To compile and link the program: either type "make", or, type manually the
output of the make command:
<PRE>
        ocamlc -o fib fib.ml
        ocamlc -o wc wc.ml
        ocamlc -o sieve sieve.ml
</PRE>

<P>As mentioned above, you can also try the programs interactively:

<PRE>
        ocaml               # or ledit ocaml if ledit is installed.
        #use "loadall.ml";;
</PRE>

<H2 ALIGN=LEFT>Native code compilation</H2>

<P>To compile the programs to native code: either type "make opt" is
a <CODE>Makefile</CODE> is provided, or, type manually the suitable commmands:

<PRE>
        ocamlopt -o fib fib.ml
        ocamlopt -o wc wc.ml
        ocamlopt -o sieve sieve.ml
</PRE>

<H2 ALIGN=LEFT>Basic programs</H2>

<P>This directory contains the following basic programs:

<DL>
<DT><STRONG>Hello</STRONG>: the source program is in file
 <A HREF="hello.ml"><CODE>hello.ml</CODE></A>.</DT>
  <DD>It just prints "Hello world!" followed by a newline.</DD>
  <DD>Try<BR>
       <CODE>hello</CODE>
  </DD>

<DT><STRONG>Greeting</STRONG>: the source program is in file
 <A HREF="greeting.ml"><CODE>greeting.ml</CODE></A>.</DT>
  <DD>It asks the name of the user, reads the input from the keyboard,
  greets the user and dies.</DD>
  <DD>Try<BR>
       <CODE>greeting</CODE>
  </DD>

<DT><STRONG>Argcargv</STRONG>: the source program is in file
 <A HREF="argcargv.ml"><CODE>argcargv.ml</CODE></A>.</DT>
  <DD>It prints the number of arguments passed to the program on the
      command line, then prints them all.</DD>
  <DD>Try<BR>
       <CODE>argcargv 1 Camel</CODE>
  </DD>

<DT><STRONG>Square</STRONG>: the source program is in file
 <A HREF="square.ml"><CODE>square.ml</CODE></A>.</DT>
  <DD>It reads an integer passed as argument to the program, then computes
  and prints the square of the integer.</DD>
  <DD>Try<BR>
       <CODE>square 16</CODE>
  </DD>

<DT><STRONG>Fib</STRONG>: the source program is in file
 <A HREF="fib.ml"><CODE>fib.ml</CODE></A>.</DT>
   <DD>It defines the Fibonacci function as a simple recursive
   Caml function.</DD>
  <DD>Try<BR>
       <CODE>fib 10</CODE>
  </DD>

<DT><STRONG>Wc</STRONG>: the source program is in file
 <A HREF="wc.ml"><CODE>wc.ml</CODE></A>.</DT>
  <DD>A program that mimicks the Unix "wc" utility: it counts the number of
  characters, words, and lines of a given file.</DD>
  <DD>Try<BR>
       <CODE>./wc wc.ml</CODE>
  </DD>

<DT><STRONG>Wc_unix</STRONG>: the source program is in file
 <A HREF="wc_unix.ml"><CODE>wc_unix.ml</CODE></A>.</DT>
  <DD>This is a Caml clone of the Unix "wc" utility.</DD>
  <DD>Try<BR>
       <CODE>./wc_unix *.ml</CODE>
  </DD>

<DT><STRONG>Reverse_stdin</STRONG>: the source program is in file
 <A HREF="reverse_stdin.ml"><CODE>reverse_stdin.ml</CODE></A>.</DT>
  <DD>It reverses the lines read from stdin.
  <BR>Vectors and imperative programming with loops.</DD>
  <DD>Try<BR>
       <CODE>reverse_stdin &lt; reverse_stdin.ml</CODE>
  </DD>

<DT><STRONG>Reverse_rec</STRONG>: the source program is in file
 <A HREF="reverse_rec.ml"><CODE>reverse_rec.ml</CODE></A>.</DT>
  <DD>Also reverses the lines read from stdin.
  <BR>Elegant recursive imperative programming.</DD>
  <DD>Try<BR>
       <CODE>reverse_rec &lt; reverse_stdin.ml</CODE>
  </DD>

<DT><STRONG>Sieve</STRONG>: the source program is in file
 <A HREF="sieve.ml"><CODE>sieve.ml</CODE></A>.</DT>
  <DD>The Eratosthene's sieve: the program computes the set of prime
  numbers lesser than a given integer argument.
  <BR>Uses lists.</DD>
  <DD>Try<BR>
       <CODE>sieve 1000</CODE>
  </DD>

<DT><STRONG>Sieve_vect</STRONG>: the source program is in file
 <A HREF="sieve_vect.ml"><CODE>sieve_vect.ml</CODE></A>.</DT>
  <DD>The Eratosthene's sieve in an imperative way, using a vector:
  the program computes the number of prime numbers lesser than a given
  integer argument. 
  <BR>Uses and manipulates vectors.</DD>
  <DD>Try<BR>
       <CODE>sieve_vect 1000</CODE>
  </DD>
  <DD><STRONG>Note</STRONG>: the C correspondant of
  <CODE>sieve_vect.ml</CODE> is in file
  <A HREF="sieve_vect.c"><CODE>sieve_vect.c</CODE></A>.
  The Caml correspondant with maximum speed is in
  <A HREF="sieve_vect_unsafe.ml"><CODE>sieve_vect_unsafe.ml</CODE></A>
  (no array bound checks).
  </DD>


<DT><STRONG>Qeens</STRONG>: the source program is in file
 <A HREF="queens.ml"><CODE>queens.ml</CODE></A>.</DT>
  <DD>Lists manipulation: prints the solution to the 8 queens problem.</DD>
  <DD>How to set n queens on a chessboard of size n such that none
  can catch one each other.
  <BR>Higher-order list manipulation.</DD>
  <DD>Try<BR>
       <CODE>queens 8</CODE>
  </DD>

<DT><STRONG>Soli</STRONG>: the source program is in file
<A HREF="soli.ml"><CODE>soli.ml</CODE></A>.</DT>
  <DD>It prints a solution to the famous ``solitaire'' game.
  <BR>Vectors and data types definitions and manipulation.</DD>
  <DD>Try<BR>
       <CODE>soli</CODE>
  </DD>
</DL>

<H2 ALIGN=LEFT>Simple library modules</H2>

<P>This directory contains two simple library module examples:

<DL>
<DT><STRONG>Realloc</STRONG>: module Realloc, the source
  implementation of the module is in file
 <A HREF="realloc.ml"><CODE>realloc.ml</CODE></A>, the source
  interface of the module is in file
 <A HREF="realloc.mli"><CODE>realloc.mli</CODE></A>.</DT>
  <DD>Defines a simple module to realloc (enlarge) arrays.
  <BR>The module defines and exports a single realloc function.
  <BR>Try to define and compile a program that uses realloc (for instance
  to define dynamically extendable storage areas).
  </DD>

<DT><STRONG>Explode</STRONG>: module Explode, the source
  implementation is in file
 <A HREF="explode.ml"><CODE>explode.ml</CODE></A>,
  the interface is in file
 <A HREF="explode.mli"><CODE>explode.mli</CODE></A>.</DT>
  <DD>Defines explode and implode, two simple functions that convert a
  string into a list of chars (explode) and converse (implode).
  <BR>Those functons are linear and tail recursive.
  </DD>

</DL>

<H2 ALIGN=LEFT>Advanced programs</H2>

<P>This directory contains the following less simple programs:

<DL>
<DT><STRONG>Strpos</STRONG>: the source program is in file
 <A HREF="strpos.ml"><CODE>strpos.ml</CODE></A>.</DT>
  <DD>Tests if its first argument appears as a sub string of its second
  argument, and returns the first character index of the first matching
  occurrence.
  <BR>Uses recursive function programming to implement a naive algorithm.</DD>
  <DD>Try<BR>
       <PRE>
        strpos rs strstr
        strpos ra strstr
        </PRE>
  </DD>

<DT><STRONG>Kmp</STRONG>: the source program is in file
 <A HREF="kmp.ml"><CODE>kmp.ml</CODE></A>.</DT>
  <DD>Tests if its first argument appears as a sub string of its second
  argument, and returns the first character index of the first matching
  occurrence.
  <BR>Uses imperative programming, while loops and references to
  implement the Knuth-Morris-Pratt algorithm.</DD>
  <DD>Try<BR>
       <PRE>
        kmp rs strstr
        kmp ra strstr
        </PRE>
  </DD>

<DT><STRONG>Qeens_tail</STRONG>: the source program is in file
 <A HREF="queens_tail.ml"><CODE>queens_tail.ml</CODE></A>.</DT>
  <DD>Same as Queens but the program is optimized, being written in a
  so called ``tail rec'' style.
  <BR>Interesting tail recursion exercise.
  </DD>
  <DD>Try<BR>
       <PRE>
        queens_tail 8
        </PRE>
  </DD>

<DT><STRONG>Qeens_lazy</STRONG>: the source program is in file
<A HREF="queens_lazy.ml"><CODE>queens_lazy.ml</CODE></A>.</DT>
  <DD>Same as Queens but the program is written in lazy style.
  Lazyness is hand coded, hence extremely explicit.
  Defines sum types to implement lazy lists, use mutable fields to
  implement call by need.
  <BR>Strange mixing of side effects and pure functionality.
  </DD>
  <DD>Try<BR>
       <PRE>
        queens_lazy 8
        </PRE>
  </DD>

</DL>

<P>
<ADDRESS>Contact the
author <A HREF="mailto:Pierre.Weis@inria.fr">Pierre.Weis@inria.fr</A></ADDRESS>
<HR>

</BODY>
</HTML>
