include Makefile.config

# OCaml tools
OCAMLFIND = @OCAMLFIND@
OCAMLLEX  = @OCAMLLEX@
OCAMLYACC = @OCAMLYACC@

# C compilers
CLANG = @CLANG@
CC = @CC@
CXX = @CXX@

# Git
GIT = @GIT@

# Libraries
ENABLE_COMPLIBS = @ENABLE_COMPLIBS@
ENABLE_GRAPHICS = @ENABLE_GRAPHICS@
ENABLE_CVC3 = @ENABLE_CVC3@
ENABLE_Z3 = @ENABLE_Z3@
ENABLE_CSISAT = @ENABLE_CSISAT@
ENABLE_RSREFINE = @ENABLE_RSREFINE@
ENABLE_AISAT = @ENABLE_AISAT@
ENABLE_GLPK = @ENABLE_GLPK@
ENABLE_CSDP = @ENABLE_CSDP@
ENABLE_GSL = @ENABLE_GSL@
ENABLE_SPPOC = @ENABLE_SPPOC@
ENABLE_ATP = @ENABLE_ATP@
ENABLE_APRON = @ENABLE_APRON@
ENABLE_CIL = @ENABLE_CIL@
ENABLE_LLVM = @ENABLE_LLVM@
ENABLE_MINISAT = @ENABLE_MINISAT@

# Normal compilation options
BFLAGS = -g -w -8 -bin-annot -annot -syntax camlp4o #-noassert #-thread
OFLAGS = -w -8 -bin-annot -annot -syntax camlp4o #-noassert #-thread

# Archiving options
CCOPT =

# Source files
SRC = global combinator printer timer logger dummy \

# Basic data structures
SRC := $(SRC) \
       util zipper \
       sexp sexpParser sexpLexer \
       bool integer nat_ float ordinal \
       option pair triple quadruple quintuple set_ bag map_ \
       vector matrix bitVector graph_ partOrd permutation combination

# Identifiers
SRC := $(SRC) \
       idnt

# Mathematical expressions
SRC := $(SRC) \
       coeff linExp monoExp polyExp \
       linIntExp linRationalExp linRealExp \
       monoIntExp monoRealExp \
       polyIntExp polyRealExp \
       linPolyIntExp

# Abstract syntax trees
SRC := $(SRC) \
       pattern absTerm \
       treeAutomaton \
       typConst typBinder type typEnv \
       const binder term typTerm \
       termSubst envFun \
       unitTerm boolTerm numTerm intTerm rationalTerm realTerm stringTerm \
       typTermSubst \
       vecTerm tupTerm ADTTerm setTerm arrayTerm \
       simTypJudge

# Formulas
SRC := $(SRC) \
       atom formula \
       literal conjunction disjunction NNF cube clause DNF CNF

# Abstract syntax trees
SRC := $(SRC) \
       cunTerm \
       linTermIntExp \

# Constraints
SRC := $(SRC) \
       linRel \
       linIntRel linTermIntRel linRationalRel linRealRel \
       polyIntRel polyRealRel \
       linPolyIntRel

# Predicates
SRC := $(SRC) \
       pred predVar pva \

# SMT Solvers
SRC := $(SRC) \
       SMTProver

# Atomic formulas
SRC := $(SRC) \
       unitAtom \
       boolAtom boolFormula boolCube boolClause \
       numAtom numLiteral numFormula \
       unifier \
       intAtom intLiteral intFormula intCube intClause \
       realAtom realFormula \
       pvaAtom pvaFormula \
       pvaCube \
       ADTAtom ADTLiteral ADTFormula \
       setAtom setLiteral setFormula \
       extConjunction extDisjunction \
       cunAtom cunLiteral cunFormula \
       tupAtom tupLiteral tupFormula

# Functions for manipulating formulas
SRC := $(SRC) \
       formulaSimplifier \
       predSubst \
       polyhedron \
       predAbst qelim qelimBody

# Rewriting systems
SRC := $(SRC) \
       equationTheory rewriteSystem knuthBendix

# Mathematical optimization
SRC := $(SRC) \
       MIP CQP \
       farkas \
       polyConstrSolver \
       bvPolyConstrSolver \
       cadPolyConstrSolver

# Horn clauses
SRC := $(SRC) \
       hornClause HCCS HCCSParser HCCSLexer

# Simple type inference
SRC := $(SRC) \
       simTypInfer

# Template expressions and size functions
SRC := $(SRC) \
       template sizeFun rankFun

# Interpolating theorem provers
SRC := $(SRC) \
       interpProver \
       checkInterpProver unitBoolInterpProver generalizingInterpProver \
       templateBasedInterpProver pointSampleInterpProver \
       \
       genInterpProver \
       CHGenInterpProver templateBasedGenInterpProver

# @todo move this to basic data structures
SRC := $(SRC) \
       partition

# Horn constraint solvers
SRC := $(SRC) \
       undefHCCSSolver unusedHCCSSolver complementHCCSSolver \
       fwHCCSSolver checkHCCSSolver \
       inlineHCCSSolver reduceHCCSSolver \
       HCCSSolver RHCCSSolver \
       unitHCCSSolver boolHCCSSolver encBoolHCCSSolver tupHCCSSolver ADTHCCSSolver \
       \
       bwIPHCCSSolver \
       bwQEHCCSSolver \
       genHCCSSolver \
       splitBoolHCCSSolver \
       templateBasedHCCSSolver \
       fwWidenHCCSSolver negaHcSolver \
       expandDagHCCSSolver \
       \
       atomHCCSSolver \
       decoHCCSSolver \
       partHCCSSolver \
       sampHCCSSolver \
       \
       beautifulHCCSSolver \
       \
       pointSampleHCCSSolver

# Interpolating prover
SRC := $(SRC) \
       HCCSInterpProver

# Exists-forall and Forall-exists Horn constraint solvers
SRC := $(SRC) \
       EAHCCSSolver AEHCCSSolver

# ML AST
SRC := $(SRC) \
       MLExp fdef prog \
       CBVEvaluator CBVInterpreter CAM ZAM \
       traceSemantics \
       callId callTree trace traceExp \
       compTree compTreeExpander

# Java AST
SRC := $(SRC) \
       javaExp javaClass javaMain javaProg javaParser javaLexer fj2ml

# Recursion schemes
SRC := $(SRC) \
       HORS

# Refinement types and abstraction types
SRC := $(SRC) \
       refType refTypJudge refTypInfer \
       absType absTypInfer \
       refTyp refTypEnv refTypCheck

# Ranking function synthesizers
SRC := $(SRC) \
       rankFunInfer \

# Misc
SRC := $(SRC) \
       regExp lazyList \
       \
       NNBackPropagate NNHopfieldModel \
       \
       matrix44 vector3 point3 frame3 \
       ray RTPoint3 sphere plane csg mesh \
       \
       ocamlInterface

## Transformation-based program verification
#SRC := $(SRC) \
#       syntax hyloParser hyloLexer hyloParser2 hyloLexer2 \
#       derive derive_tau is_out \
#       restructure reduction \
#       hyloPrinter

## Transformation-based Horn constraint solving
#SRC := $(SRC) \
#       rewriteHCCS PJoin

# Automata
SRC := $(SRC) \
       regTreeExp regTreeExpParser regTreeExpLexer \
	   treeAutomatonAtom treeAutomatonFormula treeAutomatonTerm

# Satisfiability modulo inductive predicates
SRC := $(SRC) \
       unwinding

# Horn constraint optimization
SRC := $(SRC) \
       predVarPoles predVarPriority \
       multiObjectiveHCCSSolver

# Induction-based Horn constraint solving
SRC := $(SRC) \
       proofTree inductHCCS

# ML AST
SRC := $(SRC) \
       MLRefparser MLReflexer
# MLLexer MLParser TLMLExp

# SAT solvers
SRC := $(SRC) \
       tseitinEncoding \
       SATSolver

# recursive Horn and well-foundedness constraint solvers
SRC := $(SRC) \
       CFPPAHCCSSolver LFPPAHCCSSolver recHCCSSolver WFHCCSSolver

# Program verifiers
SRC := $(SRC) \
       bench MLVerifier RCamlConst

# Symbolic game solvers
SRC := $(SRC) \
       modalMu \
       symAltParityAutomaton symAltAutomaton weakSymAltAutomaton \
       infGameArena parityGame weakParityGame recGame weakRecGame safetyGame	 livenessGame \
       game gameSolver

# Disney's HOT contracts
SRC := $(SRC) \
       ttype \
       tcontParser \
       tcontLexer \
       nfa \
       disneyTemporal

C_SRC = dummy
C_INCLUDES =
C_OPT = -fPIC
REQUIRES = str unix bigarray num extlib zarith camlp4

ifeq ($(ENABLE_COMPLIBS), 1)
  SRC := $(SRC) ppx OCamlParser repl
  REQUIRES := $(REQUIRES) compiler-libs.bytecomp compiler-libs.optcomp compiler-libs.common
endif

ifeq ($(ENABLE_GRAPHICS), 1)
  SRC := $(SRC) \
         color image shader light camera \
         raytracer
  REQUIRES := $(REQUIRES) graphics
endif

ifeq ($(ENABLE_ATP), 1)
  SRC := $(SRC) atpInterface
  REQUIRES := $(REQUIRES) atp
endif

ifeq ($(ENABLE_CSISAT), 1)
  SRC := $(SRC) CSIsatInterface
  REQUIRES := $(REQUIRES) csisat
endif

ifeq ($(ENABLE_MINISAT), 1)
  SRC := $(SRC) minisatTest
  REQUIRES := $(REQUIRES) minisat
endif

ifeq ($(ENABLE_RSREFINE), 1)
  SRC := $(SRC) \
         $(DEPCEG)/timer2 \
         $(RSREFINE)/rsutils \
         $(RSREFINE)/rsvmanager \
         $(RSREFINE)/rsdefs \
         $(RSREFINE)/rsmsat5int \
         $(RSREFINE)/rsz3int \
         $(RSREFINE)/rssat \
         $(RSREFINE)/rssmtlib \
         $(RSREFINE)/rssmt \
         $(RSREFINE)/rsexactsolver \
         $(RSREFINE)/rsunrestrictedsolver \
         $(RSREFINE)/rsm1solver \
         $(RSREFINE)/rstreesolver \
         $(RSREFINE)/rsdagsolver \
         $(RSREFINE)/rslangmanager \
         $(RSREFINE)/rsrefine \
         rsCompHCCSSolver
  INCLUDES := $(INCLUDES) -I $(DEPCEG) -I $(RSREFINE)
  REQUIRES := $(REQUIRES) rsrefine
endif

ifeq ($(ENABLE_AISAT), 1)
  SRC := $(SRC) aiSatInterface
  REQUIRES := $(REQUIRES) osdp aiSat
endif

ifeq ($(ENABLE_CVC3), 1)
  SRC := $(SRC) cvc3Interface
endif

ifeq ($(ENABLE_Z3), 1)
  SRC := $(SRC) Z3Interface
  REQUIRES := $(REQUIRES) Z3
endif

ifeq ($(ENABLE_APRON), 1)
  SRC := $(SRC) apronInterface
  REQUIRES := $(REQUIRES) apron.apron apron.polkaMPQ # apron.ppl
endif

ifeq ($(ENABLE_GLPK), 1)
  SRC := $(SRC) GLPKInterface
  CCOPT := $(CCOPT) -cclib -lglpk
  REQUIRES := $(REQUIRES) glpk
endif

ifeq ($(ENABLE_CSDP), 1)
  SRC := $(SRC) CSDPInterface
  CCOPT := $(CCOPT) -cclib -lsdp
  REQUIRES := $(REQUIRES) osdp
endif

ifeq ($(ENABLE_GSL), 1)
  SRC := $(SRC) extGSL GSLInterface
  CCOPT := $(CCOPT) -cclib -lcqp
  C_SRC := $(C_SRC) GslExtStub
  GSL=`ocamlfind query gsl`
  C_INCLUDES := $(C_INCLUDES) -I $(GSL)
  REQUIRES := $(REQUIRES) gsl
endif

ifeq ($(ENABLE_SPPOC), 1)
  SRC := $(SRC)
  REQUIRES := $(REQUIRES) sppoc
endif

ifeq ($(ENABLE_CIL), 1)
  SRC := $(SRC) heap2Array SSATrans \
         C2ML
  REQUIRES := $(REQUIRES) cil
endif

ifeq ($(ENABLE_LLVM), 1)
  SRC := $(SRC) extLLVM LLVMInterface
  C_SRC := $(C_SRC) LlvmExtStubC LlvmExtStubCpp
  C_OPT := `llvm-config --cxxflags`
  REQUIRES := $(REQUIRES) llvm llvm.bitreader llvm.analysis llvm.ipo llvm.scalar_opts
endif

SRC := $(SRC) \
       FPATConfig

PP = $(patsubst %,-package %, $(REQUIRES))

# main target
#############

NAME = fpat
all: byte opt lib

# bytecode and native-code compilation
######################################

C_OBJ = $(patsubst %, %.o, $(C_SRC))
CMO = $(patsubst %, %.cmo, $(SRC))
CMX = $(patsubst %, %.cmx, $(SRC))
#LIBCMA := $(patsubst %, %.cma, $(LIB))
#LIBCMXA := $(patsubst %, %.cmxa, $(LIB))

CMA = $(NAME).cma
CMXA = $(NAME).cmxa
A = lib$(NAME).a

$(CMX): OFLAGS += -for-pack Fpat

byte: $(CMA)
opt: $(CMXA)
lib: $(A)

funC.byte: funC.ml $(CMA)
	$(OCAMLFIND) ocamlc -g -annot -package fpat -linkpkg -o $@ funC.ml

funC.opt: funC.ml $(CMXA)
	$(OCAMLFIND) ocamlopt -annot -package fpat -linkpkg -o $@ funC.ml

rcaml.byte: rcaml.ml $(CMA)
	$(OCAMLFIND) ocamlc -g -annot -package fpat -linkpkg -o $@ rcaml.ml

rcaml.opt: rcaml.ml $(CMXA)
	$(OCAMLFIND) ocamlopt -annot -package fpat -linkpkg -o $@ rcaml.ml

$(NAME).cmo: $(CMO)
	$(OCAMLFIND) ocamlc -pack -g -o $@ $(LIBCMA) $^

$(NAME).cmx: $(CMX)
	$(OCAMLFIND) ocamlopt -pack -o $@ $(LIBCMXA) $^

$(CMA): $(NAME).cmo
	$(OCAMLFIND) ocamlc -a -custom -g -o $@ $^

$(CMXA): $(NAME).cmx
	$(OCAMLFIND) ocamlopt -a -o $@ $^

top : $(NAME).cmo
	$(OCAMLFIND) ocamlmktop -annot $(PP) -linkpkg -o $(NAME) $^

$(A) : $(C_OBJ)
	$(OCAMLFIND) ocamlmklib -o $(NAME) $^


fj2hors.byte: fj2hors.ml $(CMA)
	$(OCAMLFIND) ocamlc -g -annot -package fpat -linkpkg -o $@ fj2hors.ml

fj2hors.opt: fj2hors.ml $(CMXA)
	$(OCAMLFIND) ocamlopt -package fpat -linkpkg -o $@ fj2hors.ml

# documentation
###############

DOCDIR   = doc
DOC_SRC	 = $(CMO:.cmo=.ml) $(wildcard $(CMO:.cmo=.mli))

.PHONY: doc dot ps depgraph

$(DOCDIR)/index.html: $(DOC_SRC)
	mkdir -p $(DOCDIR)
	rm -f $(DOCDIR)/*.html
	$(OCAMLFIND) ocamldoc $(INCLUDES) $(PP) -syntax camlp4o -d $(DOCDIR) -html $(DOC_SRC)
doc: $(DOCDIR)/index.html

$(DOCDIR)/$(NAME).dot: $(DOC_SRC)
	mkdir -p $(DOCDIR)
	rm -f $(DOCDIR)/$(NAME).dot
	$(OCAMLFIND) ocamldoc $(INCLUDES) $(PP) -syntax camlp4o -o $@ -dot $(DOC_SRC)
dot: $(DOCDIR)/$(NAME).dot

$(DOCDIR)/$(NAME).ps: $(DOCDIR)/$(NAME).dot
	dot -Tps $< > $@
ps: $(DOCDIR)/$(NAME).ps

depgraph: $(DOCDIR)/$(NAME).ps
	gv $(DOCDIR)/$(NAME).ps

# generic rules
###############

.SUFFIXES: .c .cpp .mli .ml .cmi .cmo .cmx .mll .mly

.c.o:
	$(CC) -c $(C_INCLUDES) $(C_OPT) $<
#	$(CLANG) -c $(C_INCLUDES) $(C_OPT) $<

.cpp.o:
	$(CXX) -c $(C_INCLUDES) $(C_OPT) $<
#	$(CLANG) -c $(C_INCLUDES) $(C_OPT) $<

.mli.cmi:
	$(OCAMLFIND) ocamlc $(INCLUDES) $(PP) -c $(BFLAGS) $<

.ml.cmo:
	$(OCAMLFIND) ocamlc $(INCLUDES) $(PP) -c $(BFLAGS) $<

.ml.o:
	$(OCAMLFIND) ocamlopt $(INCLUDES) $(PP) -c $(OFLAGS) $<

.ml.cmx:
	$(OCAMLFIND) ocamlopt $(INCLUDES) $(PP) -c $(OFLAGS) $<

.mll.ml:
	$(OCAMLLEX) $<

.mly.ml:
	$(OCAMLYACC) -v $<

.mly.mli:
	$(OCAMLYACC) -v $<

# Makefile is rebuilt whenever Makefile.in or configure.in is modified
######################################################################

Makefile: Makefile.in config.status
	@if test -e $@; then chmod a+w $@; fi
	./config.status
	chmod a-w $@

config.status: configure
	./config.status --recheck

configure: configure.in
	autoconf

# clean
#######

clean:
	rm -f *~
	rm -f *.cm[iox] *.cmti *.cmt *.annot *.o
	rm -f $(DOCDIR)/index.html
	rm -f $(A) $(NAME).*a $(NAME).cm* $(NAME).o

dist-clean distclean: clean
	rm -f Makefile config.cache config.log config.status

git-clean gitclean:
	rm .gitignore
	git clean -df
	git checkout .gitignore

# depend
########

PARSER=$(wildcard *.mly)

.PHONY: depend
.depend depend: $(PARSER:.mly=.ml)
	$(OCAMLFIND) ocamldep $(INCLUDES) $(PP) -syntax camlp4o $(addsuffix .ml,$(SRC)) *.mli *.mly > .depend

-include .depend

# project specific rules
########################

$(ATP)/atp_batch.cma:
	cd $(ATP) && make all

$(ATP)/atp_batch.cmxa:
	cd $(ATP) && make all

# install

META: META.in Makefile
	sed -e s/REQUIRES/"$(REQUIRES)"/ $@.in | \
    sed -e s/CCOPT/"$(CCOPT)"/ > $@

install-lib: $(ATP)/atp_batch.cma $(ATP)/atp_batch.cmxa
	@if [ "$(ENABLE_ATP)" = "1" ]; then \
	  $(OCAMLFIND) remove atp; \
	  $(OCAMLFIND) install atp \
		$(ATP)/META \
		$(ATP)/atp_batch.a \
		$(ATP)/atp_batch.cmi \
		$(ATP)/atp_batch.cma \
		$(ATP)/atp_batch.cmxa; \
	fi
	@if [ "$(ENABLE_CSISAT)" = "1" ]; then \
	  $(OCAMLFIND) remove csisat; \
	  $(OCAMLFIND) install csisat \
		csisat/META \
		$(CSISAT)/obj/* \
		$(CSISAT)/lib/*; \
	fi
	@if [ "$(ENABLE_RSREFINE)" = "1" ]; then \
	  $(OCAMLFIND) remove rsrefine; \
	  $(OCAMLFIND) install rsrefine \
		rsrefine/META \
		$(OCAMLMATHSAT5)/libmsat5_stubs.a \
		$(OCAMLMATHSAT5)/ocamlmsat5.a \
		$(OCAMLMATHSAT5)/ocamlmsat5.cmi \
		$(OCAMLMATHSAT5)/ocamlmsat5.cmxa \
		$(MATHSAT5)/lib/libmathsat.a \
		$(OCAMLMINISAT)/libminisat_stubs.a \
		$(OCAMLMINISAT)/ocamlminisat.a \
		$(OCAMLMINISAT)/ocamlminisat.cmi \
		$(OCAMLMINISAT)/ocamlminisat.cmxa \
		$(MINISAT)/libminisat_drup.a; \
	fi
	@if [ "$(ENABLE_AISAT)" = "1" ]; then \
	  $(OCAMLFIND) ocamlc -pack -g -o aiSat.cmo $(AISAT)/util.cmo $(AISAT)/myPolynomial.cmo $(AISAT)/sdpConverter.cmo $(AISAT)/constraint.cmo $(AISAT)/problem.cmo; \
	  $(OCAMLFIND) ocamlopt -pack -o aiSat.cmx $(AISAT)/util.cmx $(AISAT)/myPolynomial.cmx $(AISAT)/sdpConverter.cmx $(AISAT)/constraint.cmx $(AISAT)/problem.cmx; \
#	  $(OCAMLFIND) ocamlc -pack -g -o aiSat.cmo $(AISAT)/util.cmo $(AISAT)/myPolynomial.cmo $(AISAT)/sdpConverter.cmo $(AISAT)/diminf.cmo $(AISAT)/constraint.cmo $(AISAT)/problem.cmo; \
#	  $(OCAMLFIND) ocamlopt -pack -o aiSat.cmx $(AISAT)/util.cmx $(AISAT)/myPolynomial.cmx $(AISAT)/sdpConverter.cmx $(AISAT)/diminf.cmx $(AISAT)/constraint.cmx $(AISAT)/problem.cmx; \
	  $(OCAMLFIND) ocamlc -a -custom -g -o aiSat.cma aiSat.cmo; \
	  $(OCAMLFIND) ocamlopt -a -o aiSat.cmxa aiSat.cmx; \
	  $(OCAMLFIND) remove aiSat; \
	  $(OCAMLFIND) install aiSat \
		aisat/META \
		aiSat.a \
		aiSat.cmi \
		aiSat.cma \
		aiSat.cmxa; \
	fi
	@if [ "$(ENABLE_SPPOC)" = "1" ]; then \
	  $(OCAMLFIND) remove sppoc; \
	  $(OCAMLFIND) install sppoc \
		sppoc/META \
		$(SPPOC)/MlTools/MlTools.a \
		$(SPPOC)/MlTools/MlTools.cma \
		$(SPPOC)/MlTools/MlTools.cmxa \
		$(SPPOC)/Formel/Formel.a \
		$(SPPOC)/Formel/Formel.cma \
		$(SPPOC)/Formel/Formel.cmxa \
		$(SPPOC)/Formel/sPPoC.cmi \
		$(SPPOC)/Formel/sPPoC.mli \
		$(SPPOC)/libs/*; \
	fi

install: META
	$(OCAMLFIND) remove fpat
	$(OCAMLFIND) install fpat \
		META fpat.a fpat.cmi $(CMA) $(CMXA) $(A)

BIN_NAME = rcaml
BIN_DIR = rcaml_bin

bin: $(BIN_NAME).opt
	@echo make $(BIN_DIR)
	@mkdir -p $(BIN_DIR)/bin
	@cp $(BIN_NAME).opt $(BIN_DIR)/bin
	@mkdir -p $(BIN_DIR)/lib
	@ldd $(BIN_NAME).opt | while read line; \
	do \
	   if [ $$(echo $$line | wc -w) -eq 2 ]; then \
	     cp $$(echo $$line | cut -d' ' -f1) $(BIN_DIR)/lib ; \
	   elif [ $$(echo $$line | wc -w) -eq 4 ]; then \
	     cp $$(echo $$line | cut -d' ' -f3) $(BIN_DIR)/lib ; \
	   fi; \
	done
	@mkdir -p $(BIN_DIR)/stdlib
	@cp $$($(OCAMLFIND) ocamlc -where)/*.cmi $(BIN_DIR)/stdlib
	@tar czvf $(BIN_DIR).tar.gz $(BIN_DIR)
