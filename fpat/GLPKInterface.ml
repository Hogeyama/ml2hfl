open Util
open Combinator
open Glpk
open MIP

(** Interface to GLPK *)

(** @return a pair of maximum/minimum value, maximum/minimum point *)
let solve_mip_glpk mip =
  let glpk_mip =
    make_problem
      (if mip.max then Maximize else Minimize)
      (mip.vc |> Vector.array_of)
      (mip.mA |> Matrix.array_of)
      (List.zip mip.vb1 mip.vb2 |> Vector.array_of)
      (List.zip mip.vl mip.vu |> Vector.array_of)
  in
  set_message_level glpk_mip 0;
  Logger.log (fun () -> set_message_level glpk_mip 3;);
  List.iteri
    (fun i (_, ty)  ->
       set_col_kind
         glpk_mip i
         (if Type.is_real ty then Continuous_var
          else if Type.is_int ty then Integer_var
          else assert false))
    mip.env;
  scale_problem glpk_mip;
  use_presolver glpk_mip true;
  try
    simplex glpk_mip;
    branch_and_bound_opt glpk_mip; (* necessary to solve MIP *)
    get_obj_val glpk_mip,
    get_col_primals glpk_mip |> Vector.of_array
  with
  | No_primal_feasible_solution
  | No_dual_feasible_solution -> raise PolyConstrSolver.NoSolution
  | _ -> raise PolyConstrSolver.Unknown
let solve_mip_glpk =
  Logger.log_block1
    "GLPKInterface.solve_mip_glpk"
    ~before:(Logger.printf "%a@," MIP.pr)
    ~after:(fun (f, v) ->
        Logger.printf2
          "Maximum (or minimum) %a is found at:@,%a@,"
          Float.pr f Vector.pr_float v)
    solve_mip_glpk

(** A linear constraint solver based on mixed integer programming *)
let solve_mip mip =
  mip
  |> solve_mip_glpk
  |> snd
  |> List.map2
    (fun (x, ty) f ->
       if Type.is_int ty then begin
         let n = Float.round f in
         Logger.printf3 "%a = %a (%a)@," Idnt.pr x Integer.pr n Float.pr f;
         assert (float_of_int n = f);
         x, IntTerm.make n
       end else if Type.is_real ty then begin
         Logger.printf2 "%a = %a@," Idnt.pr x Float.pr f;
         x, RealTerm.make f
       end else assert false)
    mip.env

(** @require [phi] is generated by
    [PolyConstrSolver.gen_coeff_constr ~pos:true ~linear:true] *)
let solve phi =
  try
    let sol =
      phi (* @note the coefficients are of the int type *)
      |> ((MIP.of_formula_nat >> solve_mip)
          |> PolyConstrSolver.solve_quick
          |> PolyConstrSolver.solve_int_by_nat)
    in
    sol
    (*if PolyConstrSolver.check phi sol then begin
      Logger.printf0 "MIP succeeded@,";
      sol
    end else begin
      Logger.printf2
        "MIP failed:@,  %a@,  %a@,"
        Formula.pr phi TermSubst.pr sol;
      PolyConstrSolver.solve_nat_fvs PolyConstrSolver.solve phi (* @todo *)
    end*)
  with
  | PolyConstrSolver.NoSolution
  | PolyConstrSolver.Unknown
  | MIP.NonMIP ->
    Logger.printf "MIP failed (unknown):@,  %a@," Formula.pr phi;
    PolyConstrSolver.solve_nat_fvs PolyConstrSolver.solve_dyn phi (* @todo *)
let solve =
  Logger.log_block1
    "GLPKInterface.solve"
    ~before:(Logger.printf "input: %a@," Formula.pr)
    solve

let _ = PolyConstrSolver.ext_solve_glpk := solve




let test () =
  MIP.make
    [Idnt.make "x1", Type.mk_int;
     Idnt.make "x2", Type.mk_int;
     Idnt.make "x3", Type.mk_int]
    true
    [ 10.; 6.; 4. ]
    [ [  1.; 1.; 1. ];
      [ 10.; 4.; 5. ];
      [  2.; 2.; 6. ] ]
    [ -.infinity; -.infinity; -.infinity ]
    [ 100.; 600.; 300. ]
    [ 0.; 0.; 0. ]
    [ infinity; infinity; infinity ]
  |> solve_mip_glpk
