%BEGING
RSFDStart -> G_1 0.
G_1 x -> _case 5 x CASE1 var (br fail fail) (br fail fail) CASE2.
KIf_1 op e2 e3 e4 x -> Insert_let_1 (G_1 e2) (KIf2_1 op e3 e4 x).
KArray_1 e2 x -> Insert_let_1 (G_1 e2) (KArray2_1 x).
Copy_1 x -> _case 5 x CASE3 var (br nil (cons (Copy_1 1) (Copy_1 2))) (br nil (cons (Copy_1 0) (Copy_1 3))) CASE4.
KApp_1 e2s f -> Bind_1 f nil e2s.
BindT_1 xs es -> _case 5 es (br (br (br (br fail (br fail fail)) (br fail (br fail fail))) (br (br fail (br fail fail)) (br fail (br fail fail)))) (br (br (br fail (br fail fail)) (br fail (br fail fail))) (br (br fail (br fail fail)) (br (br fail fail) (br fail fail))))) fail (br (tuple xs) (Insert_let_1 (G_1 1) (KBindT_1 xs 2))) (br (tuple xs) (Insert_let_1 (G_1 0) (KBindT_1 xs 3))) (br (br (br (br fail fail) (br fail (br fail fail))) (br (br fail fail) (br fail (br fail fail)))) (br (br (br fail fail) (br fail (br fail fail))) (br (br fail (br fail fail)) (br fail (br fail fail))))).
KLetTuple_1 xts e2 y -> lettuple (Copy_1 xts) y (G_1 e2).
KBinOp_1 op e x -> Insert_let_1 (G_1 e) (op x).
Insert_let_1 exp k -> Insert_let2_1 4 k.
KPut_1 e2 e3 x -> Insert_let_1 (G_1 e2) (KPut2_1 e3 x).
KIf2_1 op e3 e4 x y -> op x y (G_1 e3) (G_1 e4).
KArray2_1 x y -> app var (cons x (cons y nil)).
Bind_1 f xs e2s -> _case 5 e2s (br (br (br (br fail (br fail fail)) (br fail (br fail fail))) (br (br fail (br fail fail)) (br fail (br fail fail)))) (br (br (br fail (br fail fail)) (br fail (br fail fail))) (br (br fail (br fail fail)) (br (br fail fail) (br fail fail))))) fail (br (app f xs) (Insert_let_1 (G_1 1) (KBind_1 f xs 2))) (br (app f xs) (Insert_let_1 (G_1 0) (KBind_1 f xs 3))) (br (br (br (br fail fail) (br fail (br fail fail))) (br (br fail fail) (br fail (br fail fail)))) (br (br (br fail fail) (br fail (br fail fail))) (br (br fail (br fail fail)) (br fail (br fail fail))))).
KBindT_1 xs es x -> BindT_1 (Append_1 2 x) es.
Insert_let2_1 exp k -> _case 5 exp (CASE5 exp k) (k var) (br fail fail) (br fail fail) (CASE6 exp k).
KPut2_1 e3 x y -> Insert_let_1 (G_1 e3) (put x y).
KBind_1 f xs e2s x -> Bind_1 f (Append_1 2 x) e2s.
Append_1 xs x -> _case 5 xs (br (br (br (br fail (br fail fail)) (br fail (br fail fail))) (br (br fail (br fail fail)) (br fail (br fail fail)))) (br (br (br fail (br fail fail)) (br fail (br fail fail))) (br (br fail (br fail fail)) (br (br fail fail) (br fail fail))))) fail (br (cons x nil) (cons (Copy_1 1) (Append_1 2 x))) (br (cons x nil) (cons (Copy_1 0) (Append_1 3 x))) (br (br (br (br fail fail) (br fail (br fail fail))) (br (br fail fail) (br fail (br fail fail)))) (br (br (br fail fail) (br fail (br fail fail))) (br (br fail (br fail fail)) (br fail (br fail fail))))).
CASE1 -> br (br (br (br unit (br int int)) (br float (br (G_1 0) (Insert_let_1 (G_1 0) neg)))) (br (br (Insert_let_1 (G_1 0) (KBinOp_1 add 0)) (br (Insert_let_1 (G_1 0) (KBinOp_1 sub 0)) (Insert_let_1 (G_1 0) fneg))) (br (Insert_let_1 (G_1 0) (KBinOp_1 fadd 0)) (br (Insert_let_1 (G_1 0) (KBinOp_1 fsub 0)) (Insert_let_1 (G_1 0) (KBinOp_1 fmul 0)))))) (br (br (br (Insert_let_1 (G_1 0) (KBinOp_1 fdiv 0)) (br (G_1 0) (G_1 0))) (br (br (br (br (br (G_1 0) (br (G_1 0) (G_1 0))) (br (G_1 0) (br (G_1 0) (G_1 0)))) (br (br (G_1 0) (br (G_1 0) (G_1 0))) (br (G_1 0) (br (G_1 0) (G_1 0))))) (br (br (br (G_1 0) (br (Insert_let_1 (G_1 0) (KIf_1 ifeq 0 0 0)) (Insert_let_1 (G_1 0) (KIf_1 ifle 0 0 0)))) (br (G_1 0) (br (G_1 0) (G_1 0)))) (br (br (G_1 0) (br (G_1 0) (G_1 0))) (br (br (G_1 0) (G_1 0)) (br (G_1 0) (G_1 0)))))) (br (let (Copy_1 1) (G_1 0) (G_1 0)) var))) (br (br (letrec (Copy_1 1) (Copy_1 2) (G_1 0) (G_1 0)) (br (Insert_let_1 (G_1 0) (KApp_1 3)) (BindT_1 nil 3))) (br (br (Insert_let_1 (G_1 0) (KLetTuple_1 2 0)) (Insert_let_1 (G_1 0) (KArray_1 0))) (br (Insert_let_1 (G_1 0) (KBinOp_1 get 0)) (Insert_let_1 (G_1 0) (KPut_1 0 0)))))).
CASE2 -> br (br (br (br unit int) (br float (br (Insert_let_1 (G_1 1) neg) (Insert_let_1 (G_1 1) (KBinOp_1 add 1))))) (br (br (Insert_let_1 (G_1 1) (KBinOp_1 sub 1)) (Insert_let_1 (G_1 1) fneg)) (br (Insert_let_1 (G_1 1) (KBinOp_1 fadd 1)) (br (Insert_let_1 (G_1 1) (KBinOp_1 fsub 1)) (Insert_let_1 (G_1 1) (KBinOp_1 fmul 1)))))) (br (br (br (Insert_let_1 (G_1 1) (KBinOp_1 fdiv 1)) fail) (br fail (br (let (Copy_1 1) (G_1 4) (G_1 4)) var))) (br (br (letrec (Copy_1 1) (Copy_1 2) (G_1 4) (G_1 4)) (br (Insert_let_1 (G_1 1) (KApp_1 2)) (BindT_1 nil 2))) (br (Insert_let_1 (G_1 1) (KLetTuple_1 2 4)) (br (Insert_let_1 (G_1 1) (KBinOp_1 get 1)) (Insert_let_1 (G_1 1) (KPut_1 1 1)))))).
CASE3 -> br (br (br (br unit (br bool int)) (br float (br (not (Copy_1 0)) (neg (Copy_1 0))))) (br (br (add (Copy_1 0) (Copy_1 0)) (br (sub (Copy_1 0) (Copy_1 0)) (fneg (Copy_1 0)))) (br (fadd (Copy_1 0) (Copy_1 0)) (br (fsub (Copy_1 0) (Copy_1 0)) (fmul (Copy_1 0) (Copy_1 0)))))) (br (br (br (fdiv (Copy_1 0) (Copy_1 0)) (br (eq (Copy_1 0) (Copy_1 0)) (le (Copy_1 0) (Copy_1 0)))) (br (if (Copy_1 0) (Copy_1 0) (Copy_1 0)) (br (let (Copy_1 1) (Copy_1 0) (Copy_1 0)) var))) (br (br (letrec (Copy_1 1) (Copy_1 2) (Copy_1 0) (Copy_1 0)) (br (app (Copy_1 0) (Copy_1 3)) (tuple (Copy_1 3)))) (br (br (lettuple (Copy_1 2) (Copy_1 0) (Copy_1 0)) (array (Copy_1 0) (Copy_1 0))) (br (get (Copy_1 0) (Copy_1 0)) (put (Copy_1 0) (Copy_1 0) (Copy_1 0)))))).
CASE4 -> br (br (br (br unit int) (br float (br (neg (Copy_1 1)) (add (Copy_1 1) (Copy_1 1))))) (br (br (sub (Copy_1 1) (Copy_1 1)) (fneg (Copy_1 1))) (br (fadd (Copy_1 1) (Copy_1 1)) (br (fsub (Copy_1 1) (Copy_1 1)) (fmul (Copy_1 1) (Copy_1 1)))))) (br (br (br (fdiv (Copy_1 1) (Copy_1 1)) (ifeq (Copy_1 1) (Copy_1 1) (Copy_1 4) (Copy_1 4))) (br (ifle (Copy_1 1) (Copy_1 1) (Copy_1 4) (Copy_1 4)) (br (let (Copy_1 1) (Copy_1 4) (Copy_1 4)) var))) (br (br (letrec (Copy_1 1) (Copy_1 2) (Copy_1 4) (Copy_1 4)) (br (app (Copy_1 1) (Copy_1 2)) (tuple (Copy_1 2)))) (br (lettuple (Copy_1 2) (Copy_1 1) (Copy_1 4)) (br (get (Copy_1 1) (Copy_1 1)) (put (Copy_1 1) (Copy_1 1) (Copy_1 1)))))).
CASE5 exp k -> br (br (br (br (let var (Copy_1 exp) (k var)) (br fail (let var (Copy_1 exp) (k var)))) (br (let var (Copy_1 exp) (k var)) (br fail (let var (Copy_1 exp) (k var))))) (br (br (let var (Copy_1 exp) (k var)) (br (let var (Copy_1 exp) (k var)) (let var (Copy_1 exp) (k var)))) (br (let var (Copy_1 exp) (k var)) (br (let var (Copy_1 exp) (k var)) (let var (Copy_1 exp) (k var)))))) (br (br (br (let var (Copy_1 exp) (k var)) (br fail fail)) (br fail (br (let var (Copy_1 exp) (k var)) (k var)))) (br (br (let var (Copy_1 exp) (k var)) (br (let var (Copy_1 exp) (k var)) (let var (Copy_1 exp) (k var)))) (br (br (let var (Copy_1 exp) (k var)) fail) (br (let var (Copy_1 exp) (k var)) (let var (Copy_1 exp) (k var)))))).
CASE6 exp k -> br (br (br (br (let var (Copy_1 exp) (k var)) (let var (Copy_1 exp) (k var))) (br (let var (Copy_1 exp) (k var)) (br (let var (Copy_1 exp) (k var)) (let var (Copy_1 exp) (k var))))) (br (br (let var (Copy_1 exp) (k var)) (let var (Copy_1 exp) (k var))) (br (let var (Copy_1 exp) (k var)) (br (let var (Copy_1 exp) (k var)) (let var (Copy_1 exp) (k var)))))) (br (br (br (let var (Copy_1 exp) (k var)) (let var (Copy_1 exp) (k var))) (br (let var (Copy_1 exp) (k var)) (br (let var (Copy_1 exp) (k var)) (k var)))) (br (br (let var (Copy_1 exp) (k var)) (br (let var (Copy_1 exp) (k var)) (let var (Copy_1 exp) (k var)))) (br (let var (Copy_1 exp) (k var)) (br (let var (Copy_1 exp) (k var)) (let var (Copy_1 exp) (k var)))))).
%ENDG

%BEGINA
qK unit -> .
qK int -> .
qK float -> .
qK neg -> qVar.
qK add -> qVar qVar.
qK sub -> qVar qVar.
qK fneg -> qVar.
qK fadd -> qVar qVar.
qK fsub -> qVar qVar.
qK fmul -> qVar qVar.
qK fdiv -> qVar qVar.
qK ifeq -> qVar qVar qK qK.
qK ifle -> qVar qVar qK qK.
qK let -> qVar qK qK.
qK var -> .
qK letrec -> qVar qVars qK qK.
qK app -> qVar qVars.
qK tuple -> qVars.
qK lettuple -> qVars qVar qK.
qK get -> qVar qVar.
qK put -> qVar qVar qVar.
qK br -> qK qK.
qVars nil -> .
qVars cons -> qVar qVars.
qVars br -> qVars qVars.
qVar var -> .
qVar br -> qVar qVar.

%ENDA