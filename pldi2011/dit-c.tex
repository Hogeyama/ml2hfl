\section{Comparison with Dependent Intersection Type System}
\label{sec:comparison-with-dit}

This section is supplementary to Remark~1 in Section~4,
giving an example that is not typable in the dependent type system but
verifiable with our method. 

Consider the following program:
\begin{verbatim}
let f x y = if (x()>0)&&(y()<=0) then fail else () in
let h x y = x in let g n = f(h n)(h n) in g(randi())
\end{verbatim}
Given the abstraction type environment: 
\[
\begin{array}{l}
f\COL (\TUNIT\ra \INT[\lambda \nu.\nu>0]) \ra (\TUNIT\ra \INT[\lambda \nu.\nu>0]) \ra \TUNIT,\\
  g\COL \INT[\,] \ra \TUNIT,
\end{array}\]
the above program is abstracted to:
\begin{verbatim}
let f x y = if x() && not(y()) then fail else () in
let h x y = x in
let g() = let b = randb() in f (h b) (h b) in g()
\end{verbatim}
and is successfully verified by a higher-order model checker.
The above program is, however, not typable with the corresponding dependent type environment:
\[
\begin{array}{l}
f\COL ((\TUNIT\ra \rtbase{\nu}{\INT}{\nu>0}) \ra (\TUNIT\ra \rtbase{\nu}{\INT}{\nu>0})\ra \TUNIT)\\
\quad\land ((\TUNIT\ra \rtbase{\nu}{\INT}{\nu\leq 0}) \ra (\TUNIT\ra \rtbase{\nu}{\INT}{\nu\leq 0})\ra \TUNIT)\\
g\COL \INT \ra \TUNIT
\end{array}
\]
We conjecture that our method has the same verification power as
the dependent type system extended with the following rule:
\infrule[D-Or]
  {\DPT{\Delta_1,x\COL\rt{\nu}{b}{\psi_1},\Delta_2}{e}{\delta}\\
   \DPT{\Delta_1,x\COL\rt{\nu}{b}{\psi_2},\Delta_2}{e}{\delta}}
  {\DPT{\Delta_1,x\COL\rt{\nu}{b}{\psi_1\lor \psi_2},\Delta_2}{e}{\delta}}
