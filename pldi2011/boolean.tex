\section{Higher-Order Boolean Programs and Model Checking}
\label{sec:boolean}

A source program is translated to a higher-order boolean program 
(abbreviated to HBP) by the predicate abstraction discussed in 
Section~\ref{sec:pred}. The language of HBP is essentially the same as 
the source language in the previous section, except:
\begin{asparaitem}
\item The set of data types consists only of types of the form 
\(\underbrace{\TBOOL\times \cdots \times \TBOOL}_m\) (which is 
identified with \(\TUNIT\) when \(m=0\), and \(\TBOOL\) when \(m=1\)). 
We assume there are the following operators to construct or deconstruct 
tuples:
\[
\begin{array}{rcl}
\tuple{\cdot,\ldots,\cdot}&:&{\TBOOL,\ldots,\TBOOL\ra \TBOOL\times \cdots \times\TBOOL}\\
\NTH{i}&:&{\TBOOL\times\cdots\times\TBOOL\ra \TBOOL}
\end{array}
\]
\item The set of expressions is extended with \(\PARB{e_1}{e_2}\) and 
unnamed functions \(\lambda x.e\). The former is used for expressing the 
non-determinism introduced by abstractions; it is the same as 
\(\PAR{e_1}{e_2}\), which is used to express the non-determinism present 
in a source program, except that the reduction is labelled with 
\(\epsilon\). This distinction is convenient for the CEGAR 
procedure discussed in Section~\ref{sec:cegar} to find a corresponding 
execution path of the source program from an execution path of the 
abstract program.
%
Unnamed functions are used just for technical convenience for defining 
predicate abstraction;
%%presenting predicate abstraction rules given in Section~\ref{sec:pred}; 
with \(\lambda\)-lifting, we can easily get rid of 
\(\lambda\)-abstractions. (The evaluation rules and evaluation contexts 
are accordingly extended with \(E[(\lambda x.e)v]\red E[[v/x]e]\) and 
\(E ::= \cdots \mid E\,e\mid v\,E\).)
\end{asparaitem}


The following theorem is the basis of our verification method. It 
follows immediately from the decidability of the model checking of 
higher-order recursion schemes~\cite{Ong2006}.
\begin{theorem}
\label{th:decidability}Let \(D\) be an HBP. The property \(\exists 
s.(\textit{main}\tuple{}\redswith{s}{D} \FAIL)\) is decidable.
\end{theorem}
We can use a recursion scheme model checker 
\trecs{}~\cite{Kobayashi2009,Kobayashi2009d} to decide the above 
property.\footnote{The gap between the operational semantics of our 
language and that of recursion schemes can be filled by the CPS 
transformation. Note also that finite state or pushdown model checkers 
cannot be used, as higher-order programs are in general strictly more 
expressive~\cite{Damm1982}.} If \(\exists 
s.(\textit{main}\tuple{}\redswith{s}{D} \FAIL)\) holds, the model 
checker generates an error path \(s\). The knowledge about recursion 
schemes is unnecessary for understanding the rest of this paper, but an 
interested reader may wish to consult 
\cite{Ong2006,Kobayashi2009,Kobayashi2009c}.
%%for higher-order recursion schemes and their connection to program verification.
%%how to reduce various verification problems for higher-order boolean programs into
%%model checking problems for higher-order recursion schemes.
